var documenterSearchIndex = {"docs":
[{"location":"howto/#Guided-Examples","page":"Guided Examples","title":"Guided Examples","text":"","category":"section"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"This section shows examples of how to perform various tasks in CCBlade.  It assumes familiarity with basic usage.","category":"page"},{"location":"howto/#Airfoil-Data","page":"Guided Examples","title":"Airfoil Data","text":"","category":"section"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"In this example we will construct an airfoil file.  In this case we are interested in the NACA 4412.  The XFOIL simulation data for this case is available here for (Re = 10^6).","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"using PyPlot  # do this first to avoid displaying matplotlib installation, etc.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"using CCBlade\nusing PyPlot\n\nxfoildata = [\n -14.000  -1.0990   0.02637   0.02282  -0.0871   0.9992   0.0166\n -13.750  -1.0711   0.02533   0.02165  -0.0885   0.9979   0.0170\n -13.500  -1.0462   0.02365   0.01985  -0.0903   0.9963   0.0177\n -13.250  -1.0163   0.02288   0.01905  -0.0918   0.9951   0.0183\n -13.000  -0.9847   0.02237   0.01850  -0.0933   0.9943   0.0189\n -12.750  -0.9549   0.02183   0.01790  -0.0943   0.9930   0.0195\n -12.500  -0.9260   0.02126   0.01724  -0.0952   0.9911   0.0201\n -12.250  -0.8954   0.02078   0.01666  -0.0963   0.9894   0.0206\n -12.000  -0.8682   0.01946   0.01525  -0.0976   0.9877   0.0214\n -11.750  -0.8365   0.01894   0.01471  -0.0990   0.9866   0.0220\n -11.500  -0.8038   0.01852   0.01424  -0.1004   0.9857   0.0227\n -11.250  -0.7707   0.01808   0.01375  -0.1019   0.9849   0.0235\n -11.000  -0.7369   0.01769   0.01328  -0.1035   0.9843   0.0242\n -10.750  -0.7070   0.01745   0.01297  -0.1041   0.9819   0.0246\n -10.500  -0.6803   0.01619   0.01161  -0.1049   0.9793   0.0257\n -10.250  -0.6491   0.01569   0.01109  -0.1060   0.9775   0.0264\n -10.000  -0.6172   0.01529   0.01065  -0.1071   0.9759   0.0271\n  -9.750  -0.5850   0.01491   0.01022  -0.1082   0.9742   0.0279\n  -9.500  -0.5547   0.01456   0.00981  -0.1089   0.9718   0.0287\n  -9.250  -0.5287   0.01426   0.00944  -0.1085   0.9665   0.0292\n  -9.000  -0.5023   0.01345   0.00855  -0.1085   0.9622   0.0299\n  -8.750  -0.4769   0.01285   0.00791  -0.1082   0.9574   0.0309\n  -8.500  -0.4513   0.01249   0.00752  -0.1078   0.9519   0.0317\n  -8.250  -0.4243   0.01214   0.00713  -0.1076   0.9474   0.0324\n  -8.000  -0.3979   0.01184   0.00678  -0.1073   0.9422   0.0333\n  -7.750  -0.3715   0.01155   0.00644  -0.1070   0.9363   0.0340\n  -7.500  -0.3442   0.01127   0.00609  -0.1068   0.9313   0.0345\n  -7.250  -0.3183   0.01080   0.00556  -0.1064   0.9249   0.0354\n  -7.000  -0.2921   0.01033   0.00505  -0.1061   0.9186   0.0365\n  -6.750  -0.2649   0.01003   0.00471  -0.1059   0.9125   0.0375\n  -6.500  -0.2377   0.00977   0.00441  -0.1057   0.9053   0.0384\n  -6.000  -0.1825   0.00935   0.00389  -0.1054   0.8910   0.0404\n  -5.750  -0.1549   0.00912   0.00360  -0.1052   0.8835   0.0414\n  -5.500  -0.1275   0.00880   0.00325  -0.1051   0.8751   0.0435\n  -5.000  -0.0718   0.00845   0.00283  -0.1049   0.8578   0.0476\n  -4.750  -0.0441   0.00824   0.00259  -0.1047   0.8488   0.0519\n  -4.500  -0.0162   0.00810   0.00243  -0.1046   0.8388   0.0569\n  -4.250   0.0117   0.00793   0.00228  -0.1045   0.8288   0.0655\n  -4.000   0.0394   0.00780   0.00213  -0.1044   0.8184   0.0745\n  -3.750   0.0674   0.00769   0.00201  -0.1044   0.8073   0.0820\n  -3.500   0.0954   0.00761   0.00191  -0.1043   0.7964   0.0890\n  -3.250   0.1232   0.00752   0.00180  -0.1042   0.7851   0.0977\n  -3.000   0.1512   0.00745   0.00171  -0.1041   0.7733   0.1066\n  -2.750   0.1791   0.00737   0.00163  -0.1040   0.7616   0.1182\n  -2.500   0.2069   0.00729   0.00156  -0.1040   0.7497   0.1332\n  -2.250   0.2346   0.00723   0.00150  -0.1039   0.7378   0.1502\n  -2.000   0.2625   0.00715   0.00145  -0.1038   0.7254   0.1697\n  -1.750   0.2903   0.00709   0.00142  -0.1038   0.7132   0.1927\n  -1.500   0.3180   0.00703   0.00141  -0.1037   0.7012   0.2214\n  -1.250   0.3456   0.00701   0.00139  -0.1036   0.6886   0.2466\n  -1.000   0.3734   0.00697   0.00138  -0.1035   0.6754   0.2686\n  -0.750   0.4012   0.00694   0.00137  -0.1035   0.6626   0.2903\n  -0.500   0.4288   0.00691   0.00138  -0.1034   0.6497   0.3203\n  -0.250   0.4562   0.00686   0.00139  -0.1033   0.6365   0.3629\n   0.000   0.4833   0.00678   0.00141  -0.1032   0.6232   0.4192\n   0.250   0.5102   0.00658   0.00146  -0.1031   0.6101   0.5177\n   0.500   0.5366   0.00635   0.00153  -0.1029   0.5975   0.6393\n   0.750   0.5622   0.00617   0.00160  -0.1024   0.5856   0.7449\n   1.000   0.5842   0.00594   0.00170  -0.1009   0.5740   0.8717\n   1.250   0.6163   0.00588   0.00177  -0.1014   0.5622   0.9842\n   1.500   0.6525   0.00598   0.00181  -0.1033   0.5505   1.0000\n   1.750   0.6788   0.00611   0.00186  -0.1029   0.5398   1.0000\n   2.000   0.7055   0.00622   0.00192  -0.1026   0.5294   1.0000\n   2.250   0.7325   0.00633   0.00199  -0.1024   0.5204   1.0000\n   2.500   0.7592   0.00646   0.00206  -0.1022   0.5112   1.0000\n   2.750   0.7865   0.00656   0.00213  -0.1020   0.5029   1.0000\n   3.250   0.8405   0.00681   0.00231  -0.1016   0.4847   1.0000\n   3.500   0.8672   0.00696   0.00240  -0.1014   0.4746   1.0000\n   3.750   0.8941   0.00709   0.00250  -0.1012   0.4646   1.0000\n   4.000   0.9210   0.00722   0.00260  -0.1010   0.4540   1.0000\n   4.250   0.9473   0.00739   0.00272  -0.1007   0.4426   1.0000\n   4.500   0.9734   0.00758   0.00284  -0.1004   0.4273   1.0000\n   4.750   0.9993   0.00778   0.00297  -0.1001   0.4110   1.0000\n   5.000   1.0254   0.00797   0.00311  -0.0998   0.3979   1.0000\n   5.250   1.0518   0.00813   0.00326  -0.0995   0.3861   1.0000\n   5.500   1.0777   0.00834   0.00342  -0.0992   0.3731   1.0000\n   5.750   1.1031   0.00857   0.00359  -0.0988   0.3575   1.0000\n   6.000   1.1280   0.00884   0.00379  -0.0983   0.3398   1.0000\n   6.250   1.1523   0.00914   0.00401  -0.0978   0.3207   1.0000\n   6.500   1.1761   0.00948   0.00426  -0.0971   0.2993   1.0000\n   6.750   1.1988   0.00989   0.00455  -0.0963   0.2737   1.0000\n   7.000   1.2208   0.01036   0.00488  -0.0954   0.2461   1.0000\n   7.250   1.2417   0.01089   0.00526  -0.0943   0.2173   1.0000\n   7.500   1.2614   0.01149   0.00569  -0.0931   0.1865   1.0000\n   7.750   1.2793   0.01220   0.00621  -0.0915   0.1526   1.0000\n   8.000   1.2973   0.01288   0.00672  -0.0900   0.1252   1.0000\n   8.250   1.3164   0.01345   0.00719  -0.0887   0.1065   1.0000\n   8.500   1.3346   0.01404   0.00769  -0.0872   0.0893   1.0000\n   8.750   1.3514   0.01469   0.00823  -0.0854   0.0729   1.0000\n   9.000   1.3676   0.01527   0.00875  -0.0836   0.0622   1.0000\n   9.250   1.3835   0.01581   0.00926  -0.0817   0.0563   1.0000\n   9.500   1.4004   0.01631   0.00976  -0.0799   0.0521   1.0000\n   9.750   1.4171   0.01682   0.01028  -0.0782   0.0491   1.0000\n  10.000   1.4317   0.01746   0.01091  -0.0762   0.0459   1.0000\n  10.250   1.4484   0.01797   0.01147  -0.0746   0.0442   1.0000\n  10.500   1.4653   0.01849   0.01203  -0.0731   0.0427   1.0000\n  10.750   1.4805   0.01911   0.01267  -0.0714   0.0411   1.0000\n  11.000   1.4938   0.01986   0.01343  -0.0695   0.0392   1.0000\n  11.250   1.5061   0.02069   0.01430  -0.0676   0.0376   1.0000\n  11.500   1.5221   0.02129   0.01495  -0.0662   0.0368   1.0000\n  11.750   1.5369   0.02199   0.01570  -0.0647   0.0356   1.0000\n  12.000   1.5500   0.02282   0.01656  -0.0631   0.0343   1.0000\n  12.250   1.5608   0.02382   0.01758  -0.0614   0.0330   1.0000\n  12.500   1.5688   0.02506   0.01888  -0.0594   0.0316   1.0000\n  12.750   1.5831   0.02588   0.01975  -0.0582   0.0308   1.0000\n  13.000   1.5959   0.02683   0.02075  -0.0569   0.0298   1.0000\n  13.250   1.6066   0.02796   0.02192  -0.0555   0.0286   1.0000\n  13.500   1.6141   0.02939   0.02338  -0.0540   0.0273   1.0000\n  13.750   1.6213   0.03089   0.02494  -0.0526   0.0262   1.0000\n  14.000   1.6325   0.03209   0.02620  -0.0516   0.0252   1.0000\n  14.250   1.6414   0.03354   0.02770  -0.0505   0.0241   1.0000\n  14.500   1.6474   0.03528   0.02947  -0.0493   0.0229   1.0000\n  14.750   1.6508   0.03731   0.03156  -0.0482   0.0218   1.0000\n  15.000   1.6585   0.03899   0.03332  -0.0474   0.0209   1.0000\n  15.250   1.6638   0.04096   0.03533  -0.0466   0.0198   1.0000\n  15.500   1.6661   0.04330   0.03772  -0.0458   0.0187   1.0000\n  15.750   1.6666   0.04589   0.04037  -0.0451   0.0179   1.0000\n  16.000   1.6698   0.04827   0.04284  -0.0447   0.0171   1.0000\n  16.250   1.6706   0.05099   0.04562  -0.0443   0.0164   1.0000\n  16.500   1.6692   0.05402   0.04871  -0.0440   0.0157   1.0000\n  16.750   1.6638   0.05759   0.05235  -0.0439   0.0151   1.0000\n  17.000   1.6605   0.06101   0.05587  -0.0439   0.0146   1.0000\n  17.250   1.6584   0.06435   0.05931  -0.0441   0.0142   1.0000\n  17.500   1.6548   0.06793   0.06298  -0.0444   0.0138   1.0000\n  17.750   1.6497   0.07175   0.06689  -0.0448   0.0134   1.0000\n  18.000   1.6430   0.07583   0.07106  -0.0453   0.0131   1.0000\n  18.250   1.6346   0.08024   0.07555  -0.0461   0.0128   1.0000\n  18.500   1.6237   0.08507   0.08047  -0.0470   0.0124   1.0000\n  18.750   1.6097   0.09040   0.08590  -0.0482   0.0121   1.0000\n]\n\nalpha_0 = xfoildata[:, 1] * pi/180\ncl_0 = xfoildata[:, 2]\ncd_0 = xfoildata[:, 3]\n\nfigure()\nplot(alpha_0, cl_0)\nxlabel(L\"\\alpha\")\nylabel(L\"c_l\")\nsavefig(\"cl1.svg\") # hide\n\nfigure()\nplot(alpha_0, cd_0)\nxlabel(L\"\\alpha\")\nylabel(L\"c_d\")\nsavefig(\"cd1.svg\") # hide\n\nnothing # hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"(Image: ) (Image: )","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"We now need to extrapolate the data to higher angles of attack.  Even though the propeller/turbine operation might not operate outside of these angles, the solver often needs to evaluate a range of angles during the solution process so it is helpful to provide data from -pi to pi.  We will use the Viterna extrapolation, and for that we just need to know the nondimensional chord ratio (chord/R) at 75% radius.  We will use the values for the APC thin electric 10 x 5 propeller that we used in the first tutorial.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"# ---- extrapolate ------\ncr75 = 0.128\nalpha_ext, cl_ext, cd_ext = viterna(alpha_0, cl_0, cd_0, cr75)\n\nfigure()\nplot(alpha_ext, cl_ext)\nxlabel(L\"\\alpha\")\nylabel(L\"c_l\")\nsavefig(\"cl2.svg\") # hide\n\nfigure()\nplot(alpha_ext, cd_ext)\nxlabel(L\"\\alpha\")\nylabel(L\"c_d\")\nsavefig(\"cd2.svg\") # hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"(Image: ) (Image: )","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"Now we need to add various corrections.  These can either be done beforehand, or they can be evaluated on the fly.  In general one needs corrections for rotation (three-dimensional stall delay), Reynolds number, and Mach number.  The most accurate approach is to precompute the variation in Reynolds and Mach number and to evaluate rotation corrections on the fly.  However, all three can be done in any combination of precomputing or on-the-fly.  For the example we will start with the most accurate case (precompute Re/Mach and on-the-fly rotation), but will show the other variations as well.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"To address Reynolds number and Mach number variations beforehand we create 2D or 3D splines.  CCBlade provides helper functions for those scenarios.  The process is the same for Reynolds number and Mach number, and because the Mach number variation is not significant for this small propeller we will ignore it and focus just on Reynolds number.  For Reynolds number variation we would repeat the above process at multiple Reynolds numbers.  In this example we will use three different Reynolds numbers.  ","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"# data previously computed for Re = 1e6, renaming for convenience\nalpha3, cl3, cd3 = alpha_ext, cl_ext, cd_ext\n\n# ---- Re = 5e5 ------\nxfoildata2 = [\n -12.250  -0.8284   0.04176   0.03861  -0.0832   1.0000   0.0246\n -12.000  -0.8522   0.03908   0.03574  -0.0799   1.0000   0.0247\n -11.750  -0.8699   0.03540   0.03185  -0.0776   0.9997   0.0251\n -11.500  -0.8415   0.03435   0.03082  -0.0796   0.9977   0.0258\n -11.250  -0.8114   0.03347   0.02989  -0.0818   0.9957   0.0265\n -11.000  -0.7822   0.03202   0.02830  -0.0843   0.9939   0.0275\n -10.750  -0.7591   0.02982   0.02579  -0.0862   0.9905   0.0285\n -10.500  -0.7309   0.02822   0.02384  -0.0882   0.9877   0.0293\n -10.250  -0.7053   0.02556   0.02100  -0.0903   0.9856   0.0304\n -10.000  -0.6714   0.02497   0.02039  -0.0924   0.9843   0.0314\n  -9.750  -0.6435   0.02420   0.01952  -0.0932   0.9807   0.0325\n  -9.500  -0.6134   0.02311   0.01823  -0.0945   0.9778   0.0336\n  -9.250  -0.5802   0.02227   0.01716  -0.0962   0.9758   0.0345\n  -9.000  -0.5492   0.02031   0.01504  -0.0982   0.9742   0.0359\n  -8.750  -0.5132   0.01962   0.01432  -0.1004   0.9731   0.0371\n  -8.500  -0.4849   0.01894   0.01355  -0.1008   0.9683   0.0381\n  -8.250  -0.4502   0.01823   0.01273  -0.1025   0.9656   0.0394\n  -8.000  -0.4135   0.01756   0.01192  -0.1045   0.9637   0.0405\n  -7.750  -0.3794   0.01639   0.01059  -0.1062   0.9619   0.0416\n  -7.500  -0.3455   0.01547   0.00965  -0.1078   0.9602   0.0430\n  -7.250  -0.3201   0.01501   0.00917  -0.1073   0.9539   0.0442\n  -7.000  -0.2893   0.01445   0.00854  -0.1080   0.9502   0.0454\n  -6.750  -0.2573   0.01389   0.00791  -0.1088   0.9471   0.0467\n  -6.500  -0.2303   0.01351   0.00746  -0.1085   0.9415   0.0478\n  -6.250  -0.2035   0.01278   0.00668  -0.1083   0.9357   0.0494\n  -6.000  -0.1743   0.01225   0.00613  -0.1085   0.9314   0.0512\n  -5.750  -0.1485   0.01190   0.00577  -0.1080   0.9242   0.0529\n  -5.500  -0.1206   0.01155   0.00536  -0.1078   0.9180   0.0550\n  -5.250  -0.0931   0.01118   0.00493  -0.1076   0.9117   0.0575\n  -5.000  -0.0666   0.01079   0.00457  -0.1072   0.9038   0.0614\n  -4.750  -0.0382   0.01055   0.00427  -0.1071   0.8974   0.0656\n  -4.500  -0.0118   0.01018   0.00393  -0.1067   0.8884   0.0727\n  -4.250   0.0161   0.00990   0.00363  -0.1066   0.8810   0.0812\n  -4.000   0.0434   0.00973   0.00343  -0.1063   0.8716   0.0897\n  -3.750   0.0710   0.00948   0.00321  -0.1061   0.8628   0.1006\n  -3.500   0.0987   0.00929   0.00301  -0.1060   0.8534   0.1110\n  -3.250   0.1262   0.00913   0.00285  -0.1058   0.8432   0.1221\n  -3.000   0.1541   0.00898   0.00269  -0.1056   0.8335   0.1353\n  -2.750   0.1815   0.00882   0.00255  -0.1054   0.8224   0.1520\n  -2.500   0.2090   0.00867   0.00244  -0.1053   0.8113   0.1733\n  -2.250   0.2366   0.00855   0.00235  -0.1051   0.8004   0.1993\n  -2.000   0.2641   0.00844   0.00229  -0.1049   0.7887   0.2300\n  -1.750   0.2915   0.00833   0.00224  -0.1048   0.7765   0.2579\n  -1.500   0.3190   0.00826   0.00218  -0.1046   0.7645   0.2832\n  -1.250   0.3463   0.00818   0.00213  -0.1044   0.7525   0.3117\n  -1.000   0.3734   0.00807   0.00209  -0.1042   0.7397   0.3503\n  -0.750   0.4003   0.00792   0.00208  -0.1040   0.7267   0.4055\n  -0.500   0.4265   0.00766   0.00208  -0.1038   0.7141   0.5024\n  -0.250   0.4513   0.00733   0.00214  -0.1031   0.7014   0.6445\n   0.000   0.4741   0.00703   0.00220  -0.1018   0.6886   0.7752\n   0.250   0.4944   0.00681   0.00229  -0.0995   0.6757   0.9086\n   0.500   0.5429   0.00683   0.00228  -0.1037   0.6616   0.9948\n   0.750   0.5727   0.00693   0.00228  -0.1041   0.6484   1.0000\n   1.000   0.5983   0.00705   0.00231  -0.1035   0.6356   1.0000\n   1.250   0.6239   0.00719   0.00235  -0.1030   0.6230   1.0000\n   1.500   0.6499   0.00731   0.00240  -0.1026   0.6104   1.0000\n   1.750   0.6761   0.00744   0.00246  -0.1022   0.5984   1.0000\n   2.000   0.7023   0.00759   0.00253  -0.1018   0.5871   1.0000\n   2.250   0.7283   0.00775   0.00260  -0.1014   0.5758   1.0000\n   2.500   0.7548   0.00788   0.00269  -0.1011   0.5646   1.0000\n   2.750   0.7811   0.00804   0.00279  -0.1007   0.5544   1.0000\n   3.000   0.8073   0.00820   0.00290  -0.1004   0.5444   1.0000\n   3.250   0.8339   0.00834   0.00302  -0.1001   0.5349   1.0000\n   3.500   0.8600   0.00854   0.00314  -0.0998   0.5260   1.0000\n   3.750   0.8867   0.00866   0.00327  -0.0995   0.5166   1.0000\n   4.000   0.9127   0.00884   0.00341  -0.0992   0.5067   1.0000\n   4.250   0.9385   0.00902   0.00355  -0.0988   0.4957   1.0000\n   4.500   0.9647   0.00917   0.00370  -0.0984   0.4849   1.0000\n   4.750   0.9903   0.00937   0.00385  -0.0980   0.4741   1.0000\n   5.000   1.0155   0.00957   0.00400  -0.0975   0.4618   1.0000\n   5.250   1.0403   0.00977   0.00416  -0.0970   0.4460   1.0000\n   5.500   1.0652   0.00997   0.00433  -0.0964   0.4309   1.0000\n   5.750   1.0906   0.01016   0.00452  -0.0960   0.4187   1.0000\n   6.000   1.1155   0.01038   0.00472  -0.0955   0.4067   1.0000\n   6.250   1.1399   0.01063   0.00495  -0.0949   0.3935   1.0000\n   6.500   1.1639   0.01090   0.00518  -0.0942   0.3784   1.0000\n   6.750   1.1875   0.01119   0.00543  -0.0935   0.3609   1.0000\n   7.000   1.2103   0.01152   0.00571  -0.0927   0.3410   1.0000\n   7.250   1.2318   0.01193   0.00603  -0.0917   0.3191   1.0000\n   7.500   1.2528   0.01238   0.00639  -0.0906   0.2935   1.0000\n   7.750   1.2718   0.01294   0.00682  -0.0892   0.2643   1.0000\n   8.000   1.2891   0.01362   0.00734  -0.0876   0.2320   1.0000\n   8.250   1.3042   0.01442   0.00794  -0.0856   0.1973   1.0000\n   8.500   1.3175   0.01531   0.00862  -0.0834   0.1607   1.0000\n   8.750   1.3282   0.01622   0.00934  -0.0807   0.1301   1.0000\n   9.000   1.3388   0.01711   0.01011  -0.0781   0.1080   1.0000\n   9.250   1.3500   0.01798   0.01089  -0.0756   0.0904   1.0000\n   9.500   1.3615   0.01884   0.01169  -0.0732   0.0782   1.0000\n   9.750   1.3735   0.01968   0.01251  -0.0709   0.0704   1.0000\n  10.000   1.3845   0.02060   0.01340  -0.0687   0.0648   1.0000\n  10.250   1.3969   0.02144   0.01429  -0.0667   0.0610   1.0000\n  10.500   1.4094   0.02230   0.01519  -0.0648   0.0580   1.0000\n  10.750   1.4184   0.02340   0.01630  -0.0626   0.0550   1.0000\n  11.000   1.4270   0.02457   0.01753  -0.0605   0.0528   1.0000\n  11.250   1.4395   0.02551   0.01855  -0.0589   0.0510   1.0000\n  11.500   1.4503   0.02659   0.01969  -0.0573   0.0492   1.0000\n  11.750   1.4584   0.02791   0.02104  -0.0555   0.0473   1.0000\n  12.000   1.4602   0.02976   0.02294  -0.0533   0.0455   1.0000\n  12.250   1.4688   0.03116   0.02443  -0.0519   0.0443   1.0000\n  12.500   1.4791   0.03246   0.02581  -0.0507   0.0429   1.0000\n  12.750   1.4875   0.03395   0.02738  -0.0495   0.0414   1.0000\n  13.000   1.4938   0.03568   0.02917  -0.0483   0.0400   1.0000\n  13.250   1.4941   0.03801   0.03154  -0.0469   0.0387   1.0000\n  13.500   1.4941   0.04045   0.03407  -0.0457   0.0375   1.0000\n  13.750   1.5030   0.04212   0.03584  -0.0450   0.0363   1.0000\n  14.000   1.5091   0.04410   0.03790  -0.0444   0.0349   1.0000\n  14.250   1.5135   0.04630   0.04017  -0.0438   0.0337   1.0000\n  14.500   1.5126   0.04913   0.04305  -0.0432   0.0326   1.0000\n  14.750   1.5064   0.05260   0.04659  -0.0426   0.0315   1.0000\n  15.000   1.5124   0.05486   0.04898  -0.0424   0.0305   1.0000\n  15.250   1.5153   0.05748   0.05169  -0.0423   0.0294   1.0000\n  15.500   1.5171   0.06031   0.05459  -0.0423   0.0283   1.0000\n  15.750   1.5155   0.06359   0.05793  -0.0425   0.0274   1.0000\n  16.000   1.5055   0.06789   0.06228  -0.0426   0.0265   1.0000\n  16.250   1.5080   0.07082   0.06534  -0.0429   0.0257   1.0000\n  16.500   1.5081   0.07407   0.06871  -0.0433   0.0248   1.0000\n  16.750   1.5068   0.07756   0.07229  -0.0439   0.0240   1.0000\n  17.000   1.5043   0.08125   0.07605  -0.0445   0.0233   1.0000\n  17.250   1.4987   0.08538   0.08024  -0.0453   0.0226   1.0000\n]\n\nalpha = xfoildata2[:, 1] * pi/180\ncl = xfoildata2[:, 2]\ncd = xfoildata2[:, 3]\n\nalpha2, cl2, cd2 = viterna(alpha, cl, cd, cr75)\n\n# ------ Re = 2e5 ---------\nxfoildata1 = [\n  -8.500  -0.4088   0.08983   0.08647  -0.0344   1.0000   0.0813\n  -8.250  -0.4231   0.08831   0.08501  -0.0315   1.0000   0.0823\n  -8.000  -0.4442   0.08695   0.08373  -0.0282   1.0000   0.0831\n  -7.750  -0.4937   0.05313   0.04929  -0.0671   0.9865   0.0673\n  -7.500  -0.4712   0.04655   0.04243  -0.0720   0.9817   0.0641\n  -7.250  -0.4535   0.03731   0.03244  -0.0777   0.9755   0.0622\n  -7.000  -0.4231   0.03226   0.02667  -0.0816   0.9717   0.0637\n  -6.750  -0.3952   0.02910   0.02295  -0.0831   0.9655   0.0647\n  -6.500  -0.3582   0.02703   0.02031  -0.0857   0.9620   0.0660\n  -6.250  -0.3204   0.02462   0.01772  -0.0887   0.9600   0.0684\n  -6.000  -0.2930   0.02357   0.01656  -0.0890   0.9523   0.0702\n  -5.750  -0.2544   0.02238   0.01517  -0.0913   0.9489   0.0725\n  -5.500  -0.2129   0.02134   0.01390  -0.0940   0.9465   0.0756\n  -5.250  -0.1843   0.02032   0.01270  -0.0942   0.9393   0.0785\n  -5.000  -0.1466   0.01934   0.01174  -0.0963   0.9352   0.0824\n  -4.750  -0.1047   0.01855   0.01086  -0.0990   0.9326   0.0877\n  -4.500  -0.0618   0.01758   0.00989  -0.1020   0.9308   0.0951\n  -4.250  -0.0351   0.01719   0.00943  -0.1016   0.9217   0.1030\n  -4.000   0.0030   0.01638   0.00871  -0.1036   0.9180   0.1150\n  -3.750   0.0426   0.01571   0.00806  -0.1058   0.9151   0.1299\n  -3.500   0.0687   0.01531   0.00771  -0.1053   0.9057   0.1437\n  -3.250   0.1047   0.01477   0.00720  -0.1066   0.9011   0.1620\n  -3.000   0.1342   0.01437   0.00686  -0.1068   0.8934   0.1821\n  -2.750   0.1659   0.01392   0.00653  -0.1073   0.8865   0.2077\n  -2.500   0.1964   0.01352   0.00623  -0.1075   0.8792   0.2377\n  -2.250   0.2255   0.01312   0.00593  -0.1075   0.8706   0.2707\n  -2.000   0.2541   0.01274   0.00566  -0.1074   0.8618   0.3065\n  -1.750   0.2836   0.01233   0.00537  -0.1074   0.8533   0.3489\n  -1.500   0.3098   0.01195   0.00520  -0.1069   0.8424   0.4005\n  -1.250   0.3373   0.01136   0.00499  -0.1066   0.8336   0.5000\n  -1.000   0.3583   0.01070   0.00498  -0.1046   0.8222   0.6832\n  -0.500   0.4431   0.00999   0.00468  -0.1085   0.8021   1.0000\n  -0.250   0.4683   0.01000   0.00456  -0.1077   0.7890   1.0000\n   0.000   0.4938   0.01005   0.00448  -0.1071   0.7758   1.0000\n   0.250   0.5198   0.01011   0.00441  -0.1065   0.7629   1.0000\n   0.500   0.5464   0.01019   0.00435  -0.1060   0.7504   1.0000\n   0.750   0.5733   0.01027   0.00429  -0.1056   0.7383   1.0000\n   1.000   0.5988   0.01039   0.00431  -0.1050   0.7246   1.0000\n   1.250   0.6247   0.01052   0.00435  -0.1045   0.7115   1.0000\n   1.500   0.6510   0.01066   0.00439  -0.1040   0.6992   1.0000\n   1.750   0.6778   0.01082   0.00443  -0.1036   0.6876   1.0000\n   2.000   0.7038   0.01097   0.00451  -0.1032   0.6752   1.0000\n   2.250   0.7297   0.01115   0.00463  -0.1027   0.6629   1.0000\n   2.500   0.7561   0.01133   0.00474  -0.1023   0.6517   1.0000\n   2.750   0.7828   0.01152   0.00483  -0.1020   0.6409   1.0000\n   3.000   0.8084   0.01171   0.00500  -0.1014   0.6289   1.0000\n   3.250   0.8345   0.01191   0.00515  -0.1010   0.6180   1.0000\n   3.500   0.8613   0.01213   0.00528  -0.1007   0.6079   1.0000\n   3.750   0.8865   0.01233   0.00549  -0.1002   0.5965   1.0000\n   4.000   0.9127   0.01256   0.00569  -0.0998   0.5863   1.0000\n   4.250   0.9390   0.01280   0.00587  -0.0995   0.5765   1.0000\n   4.500   0.9643   0.01303   0.00613  -0.0990   0.5659   1.0000\n   4.750   0.9905   0.01330   0.00636  -0.0986   0.5563   1.0000\n   5.000   1.0156   0.01352   0.00657  -0.0980   0.5448   1.0000\n   5.250   1.0396   0.01373   0.00679  -0.0972   0.5317   1.0000\n   5.500   1.0639   0.01396   0.00701  -0.0965   0.5191   1.0000\n   5.750   1.0888   0.01422   0.00724  -0.0959   0.5080   1.0000\n   6.000   1.1122   0.01444   0.00743  -0.0950   0.4940   1.0000\n   6.250   1.1342   0.01464   0.00764  -0.0938   0.4781   1.0000\n   6.500   1.1562   0.01486   0.00788  -0.0927   0.4627   1.0000\n   6.750   1.1783   0.01510   0.00815  -0.0916   0.4482   1.0000\n   7.000   1.2002   0.01536   0.00845  -0.0905   0.4333   1.0000\n   7.250   1.2215   0.01565   0.00876  -0.0893   0.4177   1.0000\n   7.500   1.2420   0.01596   0.00908  -0.0880   0.4012   1.0000\n   7.750   1.2616   0.01630   0.00943  -0.0866   0.3835   1.0000\n   8.000   1.2799   0.01670   0.00982  -0.0849   0.3635   1.0000\n   8.250   1.2967   0.01714   0.01026  -0.0831   0.3392   1.0000\n   8.500   1.3110   0.01772   0.01076  -0.0809   0.3110   1.0000\n   8.750   1.3218   0.01847   0.01138  -0.0781   0.2773   1.0000\n   9.000   1.3267   0.01944   0.01217  -0.0745   0.2406   1.0000\n   9.250   1.3283   0.02069   0.01320  -0.0706   0.1997   1.0000\n   9.500   1.3275   0.02223   0.01449  -0.0667   0.1617   1.0000\n   9.750   1.3266   0.02391   0.01597  -0.0630   0.1356   1.0000\n  10.000   1.3275   0.02555   0.01752  -0.0598   0.1187   1.0000\n  10.250   1.3289   0.02726   0.01916  -0.0569   0.1080   1.0000\n  10.500   1.3326   0.02887   0.02077  -0.0544   0.1001   1.0000\n  10.750   1.3366   0.03055   0.02249  -0.0520   0.0942   1.0000\n  11.000   1.3429   0.03209   0.02408  -0.0501   0.0890   1.0000\n  11.250   1.3438   0.03415   0.02607  -0.0479   0.0848   1.0000\n  11.500   1.3530   0.03558   0.02764  -0.0464   0.0812   1.0000\n  11.750   1.3601   0.03722   0.02934  -0.0450   0.0776   1.0000\n  12.000   1.3641   0.03917   0.03125  -0.0433   0.0746   1.0000\n  12.250   1.3713   0.04092   0.03309  -0.0418   0.0719   1.0000\n  12.500   1.3790   0.04262   0.03491  -0.0407   0.0690   1.0000\n  12.750   1.3857   0.04441   0.03676  -0.0395   0.0664   1.0000\n  13.000   1.3923   0.04629   0.03859  -0.0382   0.0639   1.0000\n  13.250   1.4001   0.04814   0.04054  -0.0369   0.0616   1.0000\n  13.500   1.4059   0.05012   0.04268  -0.0360   0.0593   1.0000\n  13.750   1.4115   0.05212   0.04477  -0.0351   0.0571   1.0000\n  14.000   1.4180   0.05407   0.04670  -0.0342   0.0549   1.0000\n  14.250   1.4266   0.05607   0.04875  -0.0329   0.0527   1.0000\n  14.500   1.4286   0.05852   0.05141  -0.0322   0.0509   1.0000\n  14.750   1.4308   0.06101   0.05404  -0.0316   0.0491   1.0000\n  15.000   1.4342   0.06336   0.05644  -0.0312   0.0473   1.0000\n  15.250   1.4467   0.06514   0.05814  -0.0297   0.0450   1.0000\n  15.500   1.4416   0.06845   0.06172  -0.0297   0.0440   1.0000\n  15.750   1.4385   0.07175   0.06524  -0.0296   0.0427   1.0000\n  16.000   1.4362   0.07501   0.06865  -0.0296   0.0414   1.0000\n  16.250   1.4351   0.07813   0.07188  -0.0298   0.0401   1.0000\n  16.500   1.4392   0.08059   0.07434  -0.0296   0.0388   1.0000\n  16.750   1.4401   0.08377   0.07759  -0.0291   0.0376   1.0000\n  17.000   1.4274   0.08864   0.08274  -0.0304   0.0369   1.0000\n  17.250   1.4151   0.09369   0.08804  -0.0318   0.0363   1.0000\n]\n\nalpha = xfoildata1[:, 1] * pi/180\ncl = xfoildata1[:, 2]\ncd = xfoildata1[:, 3]\n\nalpha1, cl1, cd1 = viterna(alpha, cl, cd, cr75)\nnothing #hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"All the data must be the same angles of attack.  They are not in this case, so we need to interpolate the data onto a common set.  Next, we combine the cl and cd data into one matrix.  To do the interpolation we are going to use the FLOWMath package (which is already a dependency of CCBlade so should already be installed). ","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"import FLOWMath\n\n# interpolate onto alpha1-\ncl2 = FLOWMath.linear(alpha2, cl2, alpha1)\ncd2 = FLOWMath.linear(alpha2, cd2, alpha1)\ncl3 = FLOWMath.linear(alpha3, cl3, alpha1)\ncd3 = FLOWMath.linear(alpha3, cd3, alpha1)\n\nalpha = alpha1\nRe = [2e5, 5e5, 1e6]\ncl = [cl1 cl2 cl3]  # cl[i, j] corresponds to alpha[i], Re[j]\ncd = [cd1 cd2 cd3]","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"We can load that data directly into an airfoil object for usage in CCBlade.  The airfoil object creates a smooth spline based on the data (an Akima spline, or recursive Akima splines in higher dimensions). ","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"af = AlphaReAF(alpha, Re, cl, cd, \"NACA4412 (no rotation)\")\nnothing #hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"More commonly we first save it to a file so we don't have to repeat these calculations when we want to reuse this airfoil in future simulations.  We added the subscript norot in the file name just to remind ourselves that this data does not have rotational corrections.  ","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"One file corresponds to one Reynolds number and one Mach number.  The file format first contains one header line.  That is just a convenience to provide information about the airfoil data.  The next line is the Reynolds number, and the next line is the Mach number.  The rest of the file contains data in columns split by whitespace (not commas) in the following order: alpha, cl, cd.  You can add additional columns of data (e.g., cm), but they will be ignored.   For example, a simple file (a cylinder section) would look like:","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"Cylinder section with a Cd of 0.50.  Re = 1 million.\n1e6\n0.0\n-180.0   0.000   0.5000   0.000\n0.00     0.000   0.5000   0.000\n180.0    0.000   0.5000   0.000","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"For this case we have three Reynolds numbers so we need to specify three file names.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"filenames = [\"naca4412_2e5_norot.dat\", \"naca4412_5e5_norot.dat\", \"naca4412_1e6_norot.dat\"]\nwrite_af(filenames, af)","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"To reload the data from file later we can use:","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"af2 = AlphaReAF(filenames, radians=true)  # angle of attack is given in radians in the file","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"To have CCBlade apply rotation corrections on the fly we need to choose a method.  We will use the Du-Selig correction for lift and the Eggers correction for drag.  We pass this into the rotation keyword on the Rotor struct.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"Rtip = 10/2.0 * 0.0254  # inches to meters\nRhub = 0.10*Rtip\nB = 2  # number of blades\ndu = DuSeligEggers()\nrotor = Rotor(Rhub, Rtip, B, rotation=du)","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"In a similar way, if we didn't want to create 2D or 3D tables, we can compute Reynolds number and Mach number corrections on-the-fly by passing in the options re and mach respectively.  For example, let's say we only had the data for Re = 10^6 but we wanted to include some Reynolds number variation in our data.  We can use:","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"Re0 = 1e6\nsf = TurbulentSkinFriction(Re0)\n\nrotor = Rotor(Rhub, Rtip, B, rotation=du, re=sf)","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"This method simply adjusts the drag coefficient based on flat plate skin friction formulas/fits.  A similar method exists for laminar flow LaminarSkinFriction or for a user-specified exponent SkinFriction.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"For Mach number the Prandtl-Glauert correction is available, which doesn't require any inputs.  This correction only affects the lift coefficient.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"pg = PrandtlGlauert()\nrotor = Rotor(Rhub, Rtip, B, rotation=du, re=sf, mach=pg)","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"These two methods are generally less accurate than providing data beforehand because the Reynolds number variation is just based of flat plate theory rather than the actual airfoil pressure distribution, and with a pressure distribution one can use the more accurate Karman-Tsien correction for Mach number variation.  However, the magnitude of these correction is usually very minor anyway, and so the extra complication of precomputing may not be justifiable.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"A user can easily define their own correction methods for rotation, Reynolds number, Mach number, and for tip-losses (the latter is for the blade not the airfoil).  This works based on dispatch. For example, let's say you wanted a Mach number correction that also affected drag with a simple transonic drag rise model.  First, you define your own struct as a subtype of the abstract type MachCorrection.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"struct TransonicDrag <: MachCorrection\n    Mcc  # crest critical Mach number\nend","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"Then we overload the mach_correction function for this type.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"function mach_correction(td::TransonicDrag, cl, cd, Mach)\n    beta = sqrt(1 - Mach^2)\n    cl /= beta\n    cd += 20 * (Mach - td.Mcc)^4  # add estimate for compressibility drag\n    return cl, cd\nend\nnothing #hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"Now we can initialize our struct and pass it in to the rotor.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"Mcc = 0.65\ntd = TransonicDrag(Mcc)\nrotor = Rotor(Rhub, Rtip, B, rotation=du, re=sf, mach=td)\nnothing # hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"A similar procedure can be followed for any of the other correction methods.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"The last variation to consider is precomputing rotational corrections instead of  computing them on-the-fly.  While it might be more accurate to do them on-the-fly, the main advantage to precomputing everything is that we can inspect the airfoil data and make sure everything looks reasonable, and it is a bit more efficient.  ","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"We will use the same airfoil (NACA 4412), but because we  reuse this data for the validation in the introductory tutorial, we will pick out a Reynolds number closer to that operating point Re = 10^5","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"\nalpha_0 = xfoildata[:, 1] * pi/180\ncl_0 = xfoildata[:, 2]\ncd_0 = xfoildata[:, 3]\nnothing # hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"Next, we extrapolate","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"cr75 = 0.128\nalpha_ext, cl_ext, cd_ext = viterna(alpha_0, cl_0, cd_0, cr75)\nnothing # hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"Now we can apply the rotational corrections.  Most rotational correction methods require some nondimensional geometric and operational data (usually r/R, c/R, and tip-speed ratio).  Because we are doing this beforehand we don't know where on the blade we will evaluate, so we just have to pick some representative location, and some representative tip-speed ratio.  For location, 75% radius is often used, and for tip-speed ratio usually these fall within a fairly narrow range so it won't make a big difference as long we choose something reasonable.  In this example we will use a tsr of 6.  Propellers usually use advance ratio rather than tip-speed ratio, but these two quantities are related by:  lambda = pi  J (so a tip-speed ratio of 6 would be an advance ratio of about 0.5)","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"alpha_rot = alpha_ext\ncl_rot = similar(cl_ext)\ncd_rot = similar(cd_ext)\n\nrR = 0.75  # r/R = 75%\ntsr = 6.0  # representative tip-speed ratio\n\nfor i = 1:length(cl_ext)\n    cl_rot[i], cd_rot[i] = rotation_correction(DuSeligEggers(), cl_ext[i], cd_ext[i], cr75, rR, tsr, alpha_ext[i])\nend","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"We will plot these just for visualization.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"using PyPlot\n\nfigure()\nplot(alpha_0, cl_0, label=\"original\")\nplot(alpha_ext, cl_ext, label=\"extrapolated\")\nplot(alpha_rot, cl_rot, label=\"rotation\")\nxlabel(L\"\\alpha\")\nylabel(L\"c_l\")\nlegend()\nsavefig(\"clcomp.svg\") # hide\n\nfigure()\nplot(alpha_0, cd_0, label=\"original\")\nplot(alpha_ext, cd_ext, label=\"extrapolated\")\nplot(alpha_rot, cd_rot, label=\"rotation\")\nxlabel(L\"\\alpha\")\nylabel(L\"c_d\")\nlegend()\nsavefig(\"cdcomp.svg\") # hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"(Image: ) (Image: )","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"We now save this data in a file so we can reuse it.  The info field just leaves an optional header in the file.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"af_final = AlphaAF(alpha_rot, cl_rot, cd_rot, \"NACA 4412 w/ rotation\", 1e6, 0.0)\nwrite_af(\"naca4412.dat\", af_final)","category":"page"},{"location":"howto/#Wind-Turbine-Operation","page":"Guided Examples","title":"Wind Turbine Operation","text":"","category":"section"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"Nothing changes in the theory to permit operation as a propeller or as a turbine.  With sufficient change in twist, or inflow velocity, the lift will switch direction and the blade will change from requiring power to producing power.  However, to have an effective wind turbine one would want to flip the camber line so that the direction of a positive angle of attack corresponded to inflow from the \"bottom\" side of the airfoil (See Theory for more detail on this if interested).  Additionally, most of the positive conventions used for wind turbines are opposite those for propellers (directions for induction, twist, etc.).  For convenience, setting the turbine flag to true in defining the Rotor will use the positive directions shown below.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"(Image: inflowwt)","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"warning: Warning\nIf your application requires operation as both a turbine and a propeller (e.g., airborne wind) then you should pick one convention and stick with it.  Switching this flag does not force operation as a turbine, it just changes the convention for positive directions.  Those changes are merely a convenience except for camber, which is a design decision.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"As an example we will simulate the NREL 5 MW wind turbine.  Wind turbines generally have more complex inflow and airfoil schedules as compared to propellers, so this will also serve as a more advanced case compared to the introductory tutorial.  First, we load the packages.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"using CCBlade\nusing PyPlot","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"Next, we define the Rotor.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"\nRhub = 1.5\nRtip = 63.0\nB = 3\nprecone = 2.5*pi/180\n\nrotor = Rotor(Rhub, Rtip, B, precone=precone, turbine=true)\n\nnothing # hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"Next, we define the Section properties.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"\nr = [2.8667, 5.6000, 8.3333, 11.7500, 15.8500, 19.9500, 24.0500,\n    28.1500, 32.2500, 36.3500, 40.4500, 44.5500, 48.6500, 52.7500,\n    56.1667, 58.9000, 61.6333]\nchord = [3.542, 3.854, 4.167, 4.557, 4.652, 4.458, 4.249, 4.007, 3.748,\n    3.502, 3.256, 3.010, 2.764, 2.518, 2.313, 2.086, 1.419]\ntheta = pi/180*[13.308, 13.308, 13.308, 13.308, 11.480, 10.162, 9.011, 7.795,\n    6.544, 5.361, 4.188, 3.125, 2.319, 1.526, 0.863, 0.370, 0.106]\n\nnothing # hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"The airfoils are contained in files.  This wind turbine uses  8 different airfoils across the 17 different radial stations.  We first load the  airfoils, then assign them to the correct stations corresponding to the vector r defined previously.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"# Define airfoils.  In this case we have 8 different airfoils that we load into an array.\n# These airfoils are defined in files.\naftypes = Array{AlphaAF}(undef, 8)\naftypes[1] = AlphaAF(\"data/Cylinder1.dat\", radians=false)\naftypes[2] = AlphaAF(\"data/Cylinder2.dat\", radians=false)\naftypes[3] = AlphaAF(\"data/DU40_A17.dat\", radians=false)\naftypes[4] = AlphaAF(\"data/DU35_A17.dat\", radians=false)\naftypes[5] = AlphaAF(\"data/DU30_A17.dat\", radians=false)\naftypes[6] = AlphaAF(\"data/DU25_A17.dat\", radians=false)\naftypes[7] = AlphaAF(\"data/DU21_A17.dat\", radians=false)\naftypes[8] = AlphaAF(\"data/NACA64_A17.dat\", radians=false)\n\n# indices correspond to which airfoil is used at which station\naf_idx = [1, 1, 2, 3, 4, 4, 5, 6, 6, 7, 7, 8, 8, 8, 8, 8, 8]\n\n# create airfoil array \nairfoils = aftypes[af_idx]\n\n# define sections\nsections = Section.(r, chord, theta, airfoils)\n\nnothing # hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"We will use the windturbine_op function discussed in Input Structs.  The tip-speed ratio is 7.55.  We again use broadcasting because the velocities will vary at each radial station r.  There is no Reynolds or Mach number variation in our provided airfoil data and so we don't need to specify the viscosity or speed of sound.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"\n# operating point for the turbine\nyaw = 0.0*pi/180\ntilt = 5.0*pi/180\nhubHt = 90.0\nshearExp = 0.2\n\nVinf = 10.0\ntsr = 7.55\nrotorR = Rtip*cos(precone)\nOmega = Vinf*tsr/rotorR\npitch = 0.0\nazimuth = 0.0*pi/180\nrho = 1.225\n\nop = windturbine_op.(Vinf, Omega, pitch, r, precone, yaw, tilt, azimuth, hubHt, shearExp, rho)\n\nnothing # hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"We now solve","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"out = solve.(Ref(rotor), sections, op)\nnothing # hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"and plot the distributed loads:","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"# plot distributed loads\nfigure()\nplot(r/Rtip, out.Np/1e3)\nplot(r/Rtip, out.Tp/1e3)\nxlabel(\"r/Rtip\")\nylabel(\"distributed loads (kN/m)\")\nlegend([\"flapwise\", \"lead-lag\"])\nsavefig(\"loads-turbine.svg\"); nothing # hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"(Image: )","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"Next, we integrate the loads to get thrust and torque.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"T, Q = thrusttorque(rotor, sections, out)","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"This would give the thrust and torque assuming the inflow conditions were constant with azimuth (overly optimistic with this case at azimuth=0).  If one wanted to compute thrust and torque using azimuthal averaging you would compute multiple inflow conditions with different azimuth angles and then average the resulting forces.  This can be conveniently done with broadcasting.  ","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"To do this we are broadcast across r and az_angles as a matrix of conditions. We will transpose az_angles into a row vector to make this happen.  If uncomfortable with broadcasting, all of these could all be done easily with for loops.  Notice that we transpose azangles so that the there is an input column vector for r and input row vector for azangles and the output is then a matrix corresponding to all these combinations.  The thrusttorque function is overloaded with a version that accepts a matrix of outputs where outputs[i, j] corresponds to r[i], azimuth[j] then performs an integration using averaging across the azimuthal conditions (or any other parameter).","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"azangles = pi/180*[0.0, 90.0, 180.0, 270.0]\nops = windturbine_op.(Vinf, Omega, pitch, r, precone, yaw, tilt, azangles', hubHt, shearExp, rho)\nouts = solve.(Ref(rotor), sections, ops)\n\nT, Q = thrusttorque(rotor, sections, outs)","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"As a final example, let's create a nondimensional power curve for this turbine (power coefficient vs tip-speed-ratio):","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"ntsr = 20  # number of tip-speed ratios\ntsrvec = range(2, 15, length=ntsr)\ncpvec = zeros(ntsr)  # initialize arrays\nctvec = zeros(ntsr)\n\nazangles = pi/180*[0.0, 90.0, 180.0, 270.0]\n\nfor i = 1:ntsr\n    local Omega = Vinf*tsrvec[i]/rotorR\n\n    local ops = windturbine_op.(Vinf, Omega, pitch, r, precone, yaw, tilt, azangles', hubHt, shearExp, rho)\n    local outs = solve.(Ref(rotor), sections, ops)\n    local T, Q = thrusttorque(rotor, sections, outs)\n\n    cpvec[i], ctvec[i], _ = nondim(T, Q, Vinf, Omega, rho, rotor, \"windturbine\")\nend\n\nfigure()\nplot(tsrvec, cpvec)\nplot(tsrvec, ctvec)\nxlabel(\"tip speed ratio\")\nlegend([L\"C_P\", L\"C_T\"])\nsavefig(\"cpct-turbine.svg\"); nothing # hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"(Image: )","category":"page"},{"location":"howto/#Helicopter-Operation","page":"Guided Examples","title":"Helicopter Operation","text":"","category":"section"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"Let's simulate the rotorcraft geometry from this NASA report.  The setup is standard to begin with.  ","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"using CCBlade\n\nchord = 0.060\ntheta = 0.0\nRtip = 0.656\nRhub = 0.19*Rtip\nB = 3\n\nrotor = Rotor(Rhub, Rtip, B)\n\nr = range(Rhub, Rtip, length=30)\n\naf = AlphaAF(\"data/naca0012.txt\", radians=false)\nfunction af2(alpha, Re, M)\n    cl, cd = afeval(af, alpha, Re, M)\n    return cl, cd+0.014  # drag addition per report for Reynolds number adjustment\nend\nsections = Section.(r, chord, theta, af2)\nnothing # hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"Notice that we put in zero for the freestream speed.  As discussed in the Theory document, the method has been extended to handle these special cases (alternatively you can use a small nonzero number, which utilizes the standard theory, but this is prone to occassional numerical noise in the output).  Also note that we use the nondimensionalization for helicopters.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"\nrho = 1.225\nOmega = 800*pi/30\nVinf = 0.0\n\nnP = 40\npitch = range(1e-4, 20*pi/180, length=nP)\n\nCT = zeros(nP)\nCQ = zeros(nP)\nFM = zeros(nP)\n\nfor i = 1:nP\n    op = simple_op.(Vinf, Omega, r, rho, pitch=pitch[i])\n    outputs = solve.(Ref(rotor), sections, op)\n    T, Q = thrusttorque(rotor, sections, outputs)\n    FM[i], CT[i], CQ[i] = nondim(T, Q, Vinf, Omega, rho, rotor, \"helicopter\")\nend\n\nsigma = B * chord / (pi * Rtip)\nnothing # hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"Plotting the results against the provided experimental data.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"using PyPlot\n\n\nfigure()\nplot(CT/sigma, CQ/sigma, color=\"#348ABD\")\nxlim([0, 0.15])\nylim([0, 0.025])\nxlabel(L\"C_T/\\sigma\")\nylabel(L\"C_Q/\\sigma\", rotation=0)\n\ndata = [\n0.0006486486486486538 0.001826767151767151\n0.00021621621621621678 0.0019711018711018706\n0.0009729729729729721 0.0024036122661122636\n0.0021621621621621644 0.002283134095634097\n0.010594594594594595 0.0027378378378378337\n0.011351351351351346 0.0026174636174636154\n0.012540540540540546 0.0024008316008316023\n0.011675675675675679 0.003098154885654885\n0.012000000000000004 0.0034346153846153867\n0.017081081081081077 0.0035535862785862765\n0.01935135135135136 0.0036491943866943863\n0.017621621621621626 0.0029765332640332605\n0.017081081081081077 0.0028324324324324295\n0.019135135135135137 0.0027357848232848203\n0.05016216216216216 0.004891787941787941\n0.05059459459459458 0.005228222453222447\n0.054054054054054064 0.005684121621621619\n0.05502702702702702 0.006501195426195424\n0.05427027027027025 0.006597531185031182\n0.06940540540540538 0.007194854469854465\n0.07189189189189188 0.007410602910602908\n0.07243243243243241 0.007771049896049893\n0.07178378378378378 0.00810774428274428\n0.07675675675675675 0.008322895010395012\n0.0829189189189189 0.008657952182952181\n0.08572972972972973 0.009017853430353426\n0.08637837837837836 0.0090176975051975\n0.088 0.00923365384615384\n0.08637837837837836 0.009570582120582115\n0.0937297297297297 0.010602468814968808\n0.09448648648648647 0.010265748440748436\n0.09848648648648647 0.010841709979209978\n0.0963243243243243 0.011178768191268186\n0.09448648648648647 0.01264555613305613\n0.11589189189189186 0.014948102910602907\n0.11794594594594593 0.015139916839916836\n0.11816216216216216 0.015284095634095628\n0.11805405405405403 0.015596621621621619\n0.11502702702702702 0.015621387733887729\n0.11956756756756756 0.014586642411642408\n0.12054054054054059 0.014850831600831596\n0.1211891891891892 0.014850675675675672\n]\nplot(data[:, 1], data[:, 2], \"o\", color=\"#A60628\")\ntext(0.133, 0.014, \"BEM\", color=\"#348ABD\")\ntext(0.08, 0.017, \"experimental\", color=\"#A60628\")\ngca().yaxis.set_label_coords(-0.09,1.05)\nsavefig(\"rotorcraft1.svg\"); nothing # hide\n\nfigure()\nplot(CT/sigma, FM, color=\"#348ABD\")\nxlim([0, 0.15])\nylim([0, 0.7])\nxlabel(L\"C_T/\\sigma\")\nylabel(\"figure of merit\", rotation=0)\n\ndata = [\n0.0007194244604316561 0.0031982942430702765\n0.011305241521068862 0.09786780383795313\n0.017163412127440908 0.16439232409381654\n0.05056526207605345 0.45223880597014926\n0.07194244604316546 0.5462686567164178\n0.08581706063720454 0.5827292110874199\n0.09362795477903393 0.5641791044776119\n0.12127440904419323 0.5936034115138591\n0.11582733812949644 0.5533049040511726\n]\nplot(data[:, 1], data[:, 2], \"o\", color=\"#A60628\")\ntext(0.12, 0.67, \"BEM\", color=\"#348ABD\")\ntext(0.12, 0.5, \"experimental\", color=\"#A60628\")\ngca().yaxis.set_label_coords(0,1.05)\nsavefig(\"rotorcraft2.svg\"); nothing # hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"(Image: ) (Image: )","category":"page"},{"location":"howto/#Computing-Derivatives","page":"Guided Examples","title":"Computing Derivatives","text":"","category":"section"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"The code is written in a generic enough way to allow for algorithmic differentiation through the entirety of the code.  This derivative workflow is not embeded in the package for a few reasons: 1) there are many different possible input/output combinations and trying to handle the most general cases would create a lot of extra data that may not be of interest, 2) there are many different AD packages one might want to use, 3) the code is often connected to others and one might want to AD a longer chain than just around CCBlade.  In any case, setting this is up is not too difficult.  Below is an example using ForwardDiff and ReverseDiff (note that ReverseDiff currently has an issue with concatenation so you must use version 1.2.0 for this example).","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"First, let's import some needed packages.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"import ForwardDiff\nimport ReverseDiff\nusing CCBlade","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"Next, let's define the data for a simple propeller geometry.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"\nD = 1.6\nR = D/2.0\nRhub = 0.01\nRtip = D/2\nr = range(R/10, stop=9/10*R, length=11)\nchord = 0.1*ones(length(r))\nproppitch = 1.0  # pitch distance in meters.\ntheta = atan.(proppitch./(2*pi*r))\n\nfunction affunc(alpha, Re, M)\n\n    cl = 6.2*alpha\n    cd = 0.008 - 0.003*cl + 0.01*cl*cl\n\n    return cl, cd\nend \n\nn = length(r)\nairfoils = fill(affunc, n)\n\nB = 2  # number of blades\nturbine = false\npitch = 0.0\nprecone = 0.0\n\nrho = 1.225\nVinf = 30.0\nRPM = 2100\nOmega = RPM * pi/30 \n\nnothing # hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"Both ForwardDiff and ReverseDiff expect a function with a vector input and a vector output.  So we will need to create a wrapper function that takes in a vector x, which we parse into the variables of interest.  In this case we will compute thrust and torque.  This of course can be customized to any outputs of interest.  A few parameters: af, B, turbine are discrete, and cannot be differentiated, so we allow them to passthrough from the outer scope.  This part would be best wrapped in a function, rather than coming from global scope, but we're not worried about performance for this example.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"\n# parameters that passthrough: af, B, turbine\nfunction ccbladewrapper(x)\n    \n    # unpack\n    nall = length(x)\n    nvec = nall - 7\n    n = nvec  3\n\n    r = x[1:n]\n    chord = x[n+1:2*n]\n    theta = x[2*n+1:3*n]\n    Rhub = x[3*n+1]\n    Rtip = x[3*n+2]\n    pitch = x[3*n+3]\n    precone = x[3*n+4]\n    Vinf = x[3*n+5]\n    Omega = x[3*n+6]\n    rho = x[3*n+7]\n\n    rotor = Rotor(Rhub, Rtip, B; turbine=turbine, precone=precone)\n    sections = Section.(r, chord, theta, airfoils)\n    ops = simple_op.(Vinf, Omega, r, rho; pitch=pitch)\n\n    outputs = solve.(Ref(rotor), sections, ops)\n\n    T, Q = thrusttorque(rotor, sections, outputs)\n\n    return [T; Q]\nend\n\nnothing # hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"We can now evaluate the Jacobian using forward mode AD.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"\nx = [r; chord; theta; Rhub; Rtip; pitch; precone; Vinf; Omega; rho]\nJ = ForwardDiff.jacobian(ccbladewrapper, x)","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"The Jacobian in this case is a 2 x 40 matrix because we have 2 outputs and 40 inputs.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"We could calculate the Jacobian with reverse mode AD instead.  Note that below is not the most efficient way to evaluate in reverse mode, especially if the derivatives will be computed repeatedly for more inputs (see ReverseDiff documentation).","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"J2 = ReverseDiff.jacobian(ccbladewrapper, x)","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"We can check that these matricies are nearly identical:","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"println(maximum(abs.(J - J2)))","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"Generally, we should compare these derivatives against complex step, but the code is not currently complex safe, so we'll instead compare against central differencing.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"import FiniteDiff\nJ3 = FiniteDiff.finite_difference_jacobian(ccbladewrapper, x, Val{:central})\n\nimport Statistics: mean\n\nprintln(maximum(abs.(J - J3)))\nprintln(mean(abs.(J - J3)))","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"We can't expect as high of accuracy in comparing these Jacobians due to the limitations of finite differencing.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"The Jacobian is in terms of f (outputs) vs x (inputs).  For example, if we wanted to know dT/dchord we would use the same indexing we used when parsing x:","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"\ndTdchord = J[1, n+1:2*n]","category":"page"},{"location":"howto/#Computing-Derivatives-More-Efficiently","page":"Guided Examples","title":"Computing Derivatives More Efficiently","text":"","category":"section"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"The above method is simple, but not the most efficient.  First, most of the time we want to compute the derivatives many times (e.g., during an optimization) and so we should preallocate the Jacobian and populate it in place.  Second, the outputs of the wraqpper function are being reallocated many times so we should change that to be done in-place as well.  Third, if sparsity exists we should take advantage of it.  One case where sparsity occurs is when we are evaluting multiple inflow conditions (e.g., multiple flight states or multiple points on a power curve).  Each state/point is independent of the others and so there exists significant sparsity (see theory for more details). ","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"We'll use the same geometry/setup as the previous example, but with a few changes: 1) we used a setup function so that variables are not in the global scope, 2) we allow for more than one inflow conditions (nV) and so instead of 2 outputs there are 2*nV outputs, 3) we modify the outputs in place (hence the use of an exclamation mark in the function name ccbladewrapper! per Julia convention).","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"using CCBlade\nimport ForwardDiff\n\n\nfunction setup(nV)\n\n    chord = 0.10\n    D = 1.6\n    RPM = 2100\n    pitchlength = 1.0  # pitch distance in meters.\n\n    turbine = false\n    Rhub = 0.01\n    Rtip = D/2\n    B = 2  # number of blades\n\n    R = D/2.0\n    n = 11\n    r = range(R/10, stop=9/10*R, length=n)\n    theta = atan.(pitchlength./(2*pi*r))\n    chord = chord*ones(n)\n\n    function affunc(alpha, Re, M)\n\n        cl = 6.2*alpha\n        cd = 0.008 - 0.003*cl + 0.01*cl*cl\n\n        return cl, cd\n    end \n\n    airfoils = fill(affunc, n)\n\n    pitch = 0.0\n    precone = 0.0\n\n    if nV == 1\n        Vinf = [30.0]\n    else\n        Vinf = range(29.0, 31.0, length=nV) \n    end\n\n    Omega = RPM * pi/30 * ones(nV)\n    rho = 1.225 * ones(nV)\n\n    x = [r; chord; theta; Rhub; Rtip; pitch; precone; Vinf; Omega; rho]\n    y = zeros(2*nV)\n    \n    # parameters that passthrough: airfoils, B, turbine, n, nV\n    function ccbladewrapper!(y, x)\n\n        rp = x[1:n]\n        chordp = x[n+1:2*n]\n        thetap = x[2*n+1:3*n]\n        Rhubp = x[3*n+1]\n        Rtipp = x[3*n+2]\n        pitchp = x[3*n+3]\n        preconep = x[3*n+4]\n        idx = 3*n+4\n        Vinfp = x[idx+1:idx+nV]\n        Omegap = x[idx+nV+1:idx+2*nV]\n        rhop = x[idx+2*nV+1:idx+3*nV]\n\n        rotor = Rotor(Rhubp, Rtipp, B, turbine=turbine, precone=preconep)\n        sections = Section.(rp, chordp, thetap, airfoils)\n        ops = simple_op.(Vinfp', Omegap', rp, rhop')\n\n        outputs = solve.(Ref(rotor), sections, ops)\n\n        for i = 1:nV\n            T, Q = thrusttorque(rotor, sections, outputs[:, i])\n            y[i] = T\n            y[i+nV] = Q\n        end\n\n        return nothing\n    end\n\n    return x, y, ccbladewrapper!\nend\nnothing # hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"Let's now use the same ForwardDiff setup we used previously, but now with an output function that modifies in place, and we will preallocate the Jacobian use the jacobian! function that modifies in place (we also preallocate the config see ForwardDiff documentation).  We will consider a case with 128 inflow conditions.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"nV = 128\nx, y, func = setup(nV)\nconfig = ForwardDiff.JacobianConfig(func, y, x)\nJ = zeros(length(y), length(x))  # preallocate Jacobian\nForwardDiff.jacobian!(J, func, y, x, config)  # results stored in J\nnothing # hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"We can compute the same Jacobian, but take advantage of the significant sparsity that exists.  We will make use of the SparseDiffTools package which builds off of ForwardDiff.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"import SparseArrays\nimport SparseDiffTools\n\nJsparse = SparseArrays.sparse(J)  # allocate a sparse matrix\ncolors = SparseDiffTools.matrix_colors(Jsparse)  # determine coloring vector\ncache = SparseDiffTools.ForwardColorJacCache(func, x, dx=y, colorvec=colors, sparsity=Jsparse)  # allocate cache\nSparseDiffTools.forwarddiff_color_jacobian!(Jsparse, func, x, cache)  # compute jacobian, results stored in Jsparse\nnothing # hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"We check that both provided the same output.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"println(maximum(abs.(J - Jsparse)))","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"Let's now compare computation time.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"using BenchmarkTools\n\nt1 = @benchmark ForwardDiff.jacobian!($J, $func, $y, $x, $config)\nprintln(median(t1).time*1e-9)  # median time in seconds\nt2 = @benchmark SparseDiffTools.forwarddiff_color_jacobian!($Jsparse, $func, $x, $cache)\nprintln(median(t2).time*1e-9)  # median time in seconds","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"This represents about an order of magnitude speed up by leveraging sparsity.","category":"page"},{"location":"wake_model_examples/#Examples-using-the-cylinder-wake-model","page":"Examples using the cylinder wake model","title":"Examples using the cylinder wake model","text":"","category":"section"},{"location":"wake_model_examples/","page":"Examples using the cylinder wake model","title":"Examples using the cylinder wake model","text":"We provide examples using the wake model, in addition with supplemental material to understand the behavior of CCBlade when the wake model is on.","category":"page"},{"location":"wake_model_examples/","page":"Examples using the cylinder wake model","title":"Examples using the cylinder wake model","text":"Useful link: theory on the cylinder wake model.","category":"page"},{"location":"wake_model_examples/#Example-1:-coned-rotor","page":"Examples using the cylinder wake model","title":"Example 1: coned rotor","text":"","category":"section"},{"location":"wake_model_examples/","page":"Examples using the cylinder wake model","title":"Examples using the cylinder wake model","text":"We first consider a simple rotor with straight blades under various coning angles. As the coning increases, we expect that the radial flow component (which is neglected in the standard BEM) plays an increasingly important role.","category":"page"},{"location":"wake_model_examples/","page":"Examples using the cylinder wake model","title":"Examples using the cylinder wake model","text":"using PyPlot\nusing CCBlade\nnothing #hide","category":"page"},{"location":"wake_model_examples/","page":"Examples using the cylinder wake model","title":"Examples using the cylinder wake model","text":"Let us use the same turbine as in the other examples.","category":"page"},{"location":"wake_model_examples/","page":"Examples using the cylinder wake model","title":"Examples using the cylinder wake model","text":"    Rhub = 1.5\n    Rtip = 63.0\n    B = 3\n    hubHt = 90.0\n\n    r = [2.8667, 5.6000, 8.3333, 11.7500, 15.8500, 19.9500, 24.0500,\n        28.1500, 32.2500, 36.3500, 40.4500, 44.5500, 48.6500, 52.7500,\n        56.1667, 58.9000, 61.6333]\n    chord = [3.542, 3.854, 4.167, 4.557, 4.652, 4.458, 4.249, 4.007, 3.748,\n        3.502, 3.256, 3.010, 2.764, 2.518, 2.313, 2.086, 1.419]\n    theta = pi/180*[13.308, 13.308, 13.308, 13.308, 11.480, 10.162, 9.011, 7.795,\n        6.544, 5.361, 4.188, 3.125, 2.319, 1.526, 0.863, 0.370, 0.106]\n    \n    # Define airfoils.  In this case we have 8 different airfoils that we load into an array.\n    # These airfoils are defined in files.\n    aftypes = Array{AlphaAF}(undef, 8)\n    aftypes[1] = AlphaAF(\"data/Cylinder1.dat\", radians=false) \n    aftypes[2] = AlphaAF(\"data/Cylinder2.dat\", radians=false)\n    aftypes[3] = AlphaAF(\"data/DU40_A17.dat\", radians=false)\n    aftypes[4] = AlphaAF(\"data/DU35_A17.dat\", radians=false)\n    aftypes[5] = AlphaAF(\"data/DU30_A17.dat\", radians=false)\n    aftypes[6] = AlphaAF(\"data/DU25_A17.dat\", radians=false)\n    aftypes[7] = AlphaAF(\"data/DU21_A17.dat\", radians=false)\n    aftypes[8] = AlphaAF(\"data/NACA64_A17.dat\", radians=false)\n\n    # indices correspond to which airfoil is used at which station\n    af_idx = [1, 1, 2, 3, 4, 4, 5, 6, 6, 7, 7, 8, 8, 8, 8, 8, 8]\n    \n    # create airfoil array \n    airfoils = aftypes[af_idx]\n    \n    nothing # hide","category":"page"},{"location":"wake_model_examples/","page":"Examples using the cylinder wake model","title":"Examples using the cylinder wake model","text":"The main parameters that we want to explore the influence of are:","category":"page"},{"location":"wake_model_examples/","page":"Examples using the cylinder wake model","title":"Examples using the cylinder wake model","text":"    precone = 10.0*pi/180  #the original value is 2.5 (negtive means forward)\n    tilt = 0.0*pi/180     #the original value is 5.0 (positive means upwards)\n    yaw = 0.0*pi/180\n    shearExp = 0.0\n\n    sections = Section.(r, chord, theta, airfoils)\n    sections_coned = Section.(r, chord, theta, airfoils, precone)\n\n    nothing # hide","category":"page"},{"location":"wake_model_examples/","page":"Examples using the cylinder wake model","title":"Examples using the cylinder wake model","text":"The response to shear will also differ between the standard BEM and the one working with the wake model.","category":"page"},{"location":"wake_model_examples/","page":"Examples using the cylinder wake model","title":"Examples using the cylinder wake model","text":"We also define common operating conditions.","category":"page"},{"location":"wake_model_examples/","page":"Examples using the cylinder wake model","title":"Examples using the cylinder wake model","text":"    Vinf = 10.0\n    tsr = 7.55\n    rotorR = Rtip*cos(precone)\n    Omega = Vinf*tsr/rotorR\n    azimuth = 0.0*pi/180\n    rho = 1.225\n    pitch = 0.0\n    nothing # hide","category":"page"},{"location":"wake_model_examples/","page":"Examples using the cylinder wake model","title":"Examples using the cylinder wake model","text":"Rotor 1","category":"page"},{"location":"wake_model_examples/","page":"Examples using the cylinder wake model","title":"Examples using the cylinder wake model","text":"As a reference, we will use the unconed rotor. Note the keyword argument wakeCyl to specify wheher or not you want to activate the wake model. If false, the standard BEM routines are used.","category":"page"},{"location":"wake_model_examples/","page":"Examples using the cylinder wake model","title":"Examples using the cylinder wake model","text":"\n    rotor_nocone_nowake = Rotor(Rhub, Rtip, B; precone=0.0, turbine=true, wakeCyl=false)\n\n    op = windturbine_op.(Vinf, Vinf*tsr/Rtip, pitch, r, 0.0, yaw, tilt, azimuth, hubHt, shearExp, rho)\n    \n    out_nocone_nowake = solve.(Ref(rotor_nocone_nowake), sections, op)\n\n    nothing # hide","category":"page"},{"location":"wake_model_examples/","page":"Examples using the cylinder wake model","title":"Examples using the cylinder wake model","text":"Rotor 2","category":"page"},{"location":"wake_model_examples/","page":"Examples using the cylinder wake model","title":"Examples using the cylinder wake model","text":"The second rotor to compare with has some precone but does not use the wake model.","category":"page"},{"location":"wake_model_examples/","page":"Examples using the cylinder wake model","title":"Examples using the cylinder wake model","text":"\n    rotor_cone_nowake = Rotor(Rhub, Rtip, B; precone=precone, turbine=true, wakeCyl=false)\n\n    op = windturbine_op.(Vinf, Omega, pitch, r, precone, yaw, tilt, azimuth, hubHt, shearExp, rho)\n    \n    out_cone_nowake = solve.(Ref(rotor_cone_nowake), sections_coned, op)\n    \n    nothing # hide","category":"page"},{"location":"wake_model_examples/","page":"Examples using the cylinder wake model","title":"Examples using the cylinder wake model","text":"Rotor 3","category":"page"},{"location":"wake_model_examples/","page":"Examples using the cylinder wake model","title":"Examples using the cylinder wake model","text":"The third rotor has precone and uses the wake model.","category":"page"},{"location":"wake_model_examples/","page":"Examples using the cylinder wake model","title":"Examples using the cylinder wake model","text":"    \n    rotor_cone_wake = Rotor(Rhub, Rtip, B; precone=precone, turbine=true, wakeCyl=true)\n\n    op = windturbine_op.(Vinf, Omega, pitch, r, precone, yaw, tilt, azimuth, hubHt, shearExp, rho)\n    \n    out_cone_wake = solve.(Ref(rotor_cone_wake), sections_coned, op)\n\n    nothing # hide","category":"page"},{"location":"wake_model_examples/","page":"Examples using the cylinder wake model","title":"Examples using the cylinder wake model","text":"Comparison","category":"page"},{"location":"wake_model_examples/","page":"Examples using the cylinder wake model","title":"Examples using the cylinder wake model","text":"    figure()\n    plot(r/Rtip, out_nocone_nowake.Np/1e3)\n    plot(r/Rtip, out_cone_nowake.Np/1e3,\"--\")\n    plot(r/Rtip, out_cone_wake.Np/1e3)\n    xlabel(\"r/Rtip\")\n    ylabel(\"normal loads (kN/m)\")\n\n    savefig(\"wakeEx1_Np.svg\") # hide    \n\n    figure()\n    plot(r/Rtip, out_nocone_nowake.Tp/1e3)\n    plot(r/Rtip, out_cone_nowake.Tp/1e3,\"--\")\n    plot(r/Rtip, out_cone_wake.Tp/1e3)\n    xlabel(\"r/Rtip\")\n    ylabel(\"tangential loads (kN/m)\")\n\n    legend([\"out_nocone_nowake\", \"out_cone_nowake\", \"out_cone_wake\"])\n\n    savefig(\"wakeEx1_Tp.svg\") # hide\n\n\n    T1, Q1 = thrusttorque(rotor_nocone_nowake, sections, out_nocone_nowake)\n    T2, Q2 = thrusttorque(rotor_cone_nowake, sections, out_cone_nowake)\n    T3, Q3 = thrusttorque(rotor_cone_wake, sections, out_cone_wake)\n\n    println(\"$T1, $Q1\")\n    println(\"$T2, $Q2\")\n    println(\"$T3, $Q3\")\n\n    cpvec_nocone_nowake, ctvec_nocone_nowake, _ = nondim(T1, Q1, Vinf, Vinf*tsr/Rtip, rho, rotor_nocone_nowake, \"windturbine\")\n    cpvec_cone_nowake, ctvec_cone_nowake, _ = nondim(T2, Q2, Vinf, Omega, rho, rotor_cone_nowake, \"windturbine\")\n    cpvec_cone_wake, ctvec_cone_wake, _ = nondim(T3, Q3, Vinf, Omega, rho, rotor_cone_wake, \"windturbine\")\n\n    println(\"$cpvec_nocone_nowake, $ctvec_nocone_nowake\")\n    println(\"$cpvec_cone_nowake, $ctvec_cone_nowake\")\n    println(\"$cpvec_cone_wake, $ctvec_cone_wake\")\n\n    nothing # hide","category":"page"},{"location":"wake_model_examples/","page":"Examples using the cylinder wake model","title":"Examples using the cylinder wake model","text":"(Image: ) (Image: )","category":"page"},{"location":"wake_model_examples/","page":"Examples using the cylinder wake model","title":"Examples using the cylinder wake model","text":"Let's compare CP cuves:","category":"page"},{"location":"wake_model_examples/","page":"Examples using the cylinder wake model","title":"Examples using the cylinder wake model","text":"The wake model gives a lot more CP... is that correct?? Need data to validate this?","category":"page"},{"location":"wake_model_examples/","page":"Examples using the cylinder wake model","title":"Examples using the cylinder wake model","text":"\n    ntsr = 20  # number of tip-speed ratios\n    tsrvec = range(2, stop=15, length=ntsr)\n    \n    cpvec_nocone_nowake = zeros(ntsr)  # initialize arrays\n    ctvec_nocone_nowake = zeros(ntsr)\n    cpvec_cone_nowake = zeros(ntsr)\n    ctvec_cone_nowake = zeros(ntsr)\n    cpvec_cone_wake = zeros(ntsr)\n    ctvec_cone_wake = zeros(ntsr)\n    \n    #azangles = pi/180*[0.0, 90.0, 180.0, 270.0]\n    azangles = [0.0,]\n\n    # figure()\n    for i = 1:ntsr\n        #-1-\n        omega = Vinf*tsrvec[i]/Rtip\n        ops = windturbine_op.(Vinf, omega, pitch, r, 0.0, yaw, tilt, azangles', hubHt, shearExp, rho)\n\n        outs1 = solve.(Ref(rotor_nocone_nowake), sections, ops)   \n        T, Q = thrusttorque(rotor_nocone_nowake, sections, outs1)\n\n        cpvec_nocone_nowake[i], ctvec_nocone_nowake[i], _ = nondim(T, Q, Vinf, omega, rho, rotor_nocone_nowake, \"windturbine\")\n\n        #-2-\n        omega = Vinf*tsrvec[i]/rotorR\n        ops = windturbine_op.(Vinf, omega, pitch, r, precone, yaw, tilt, azangles', hubHt, shearExp, rho)     \n        \n        outs2 = solve.(Ref(rotor_cone_nowake), sections_coned, ops)   \n        T, Q = thrusttorque(rotor_cone_nowake, sections_coned, outs2)\n    \n        cpvec_cone_nowake[i], ctvec_cone_nowake[i], _ = nondim(T, Q, Vinf, omega, rho, rotor_cone_nowake, \"windturbine\")\n\n        #-3-\n        omega = Vinf*tsrvec[i]/rotorR\n        ops = windturbine_op.(Vinf, omega, pitch, r, precone, yaw, tilt, azangles', hubHt, shearExp, rho)     \n        \n        outs3 = solve.(Ref(rotor_cone_wake), sections_coned, ops)   \n        T, Q = thrusttorque(rotor_cone_wake, sections_coned, outs3)\n    \n        cpvec_cone_wake[i], ctvec_cone_wake[i], _ = nondim(T, Q, Vinf, omega, rho, rotor_cone_wake, \"windturbine\")\n    end\n    \n\n    figure()\n    plot(tsrvec,cpvec_nocone_nowake)\n    plot(tsrvec,cpvec_cone_nowake)\n    plot(tsrvec,cpvec_cone_wake)\n    plot(tsr,0.0,\"x\")\n    xlabel(L\"\\lambda\")\n    ylabel(L\"C_P\")\n\n    savefig(\"wakeEx1_CP.svg\") # hide\n\n    figure()\n    plot(tsrvec,ctvec_nocone_nowake)\n    plot(tsrvec,ctvec_cone_nowake)\n    plot(tsrvec,ctvec_cone_wake)\n    xlabel(L\"\\lambda\")\n    ylabel(L\"C_T\")\n\n    savefig(\"wakeEx1_CT.svg\") # hide\n\n    nothing # hide","category":"page"},{"location":"wake_model_examples/","page":"Examples using the cylinder wake model","title":"Examples using the cylinder wake model","text":"(Image: ) (Image: )","category":"page"},{"location":"wake_model_examples/#A-glitch-with-negative-cone?","page":"Examples using the cylinder wake model","title":"A glitch with negative cone?","text":"","category":"section"},{"location":"wake_model_examples/","page":"Examples using the cylinder wake model","title":"Examples using the cylinder wake model","text":"The residual seem not well behaved. What about starting up the solver in the center of the interval, instead of close to 0?","category":"page"},{"location":"wake_model_examples/","page":"Examples using the cylinder wake model","title":"Examples using the cylinder wake model","text":"\n\n    #CHOOSE A SPANWISE LOCATION index\n    isp = length(r)-1\n\n    #negative precone\n    precone = -2.5*pi/180\n\n    #recompute what we need:\n    sections = Section.(r, chord, theta, airfoils, precone)\n\n    rotor_nowake = Rotor(Rhub, Rtip, B; precone=precone, turbine=true, wakeCyl=false)\n    rotor_wake = Rotor(Rhub, Rtip, B; precone=precone, turbine=true, wakeCyl=true)\n\n    rotorR = Rtip*cos(precone)\n    Omega = Vinf*tsr/rotorR\n    op = windturbine_op.(Vinf, Omega, pitch, r, precone, yaw, tilt, azimuth, hubHt, shearExp, rho)\n    \n\n    # -- solve --\n\n    out_nowake = solve.(Ref(rotor_nowake), sections, op)\n    out_wake = solve.(Ref(rotor_wake), sections, op)\n\n    figure()\n    plot(r/Rtip, out_nowake.phi.*180. /pi)\n    plot(r/Rtip, out_wake.phi.*180. /pi)\n    plot(r[isp]/Rtip, 0.,\"x\") #THIS IS THE LOCAATION WE CHOSE FOR LOOKING AT RESIDUALS\n\n    xlabel(L\"r/R\")\n    ylabel(L\"\\phi\")\n\n    legend([\"no cylinder wake\", \"with cylinder wake\"])\n\n    savefig(\"wakeEx1.1_phi.svg\") # hide\n\n\n    # -- residual --\n\n    #creating phi vector refined near 0\n    nn = 1000\n    p1 = range(-180.,-1.,length=100)\n    p2 = range(-1,1.,length=nn)\n    phi = vcat(p1[1:end-1],p2,-p1[end-1:-1:1])\n    \n    Res_wake = zero(phi)\n    Res_nowake = zero(phi)\n\n    # compute and plot the residual \n    for i =1:length(phi)\n        Res_nowake[i] = CCBlade.residual(phi[i].* pi/180, rotor_nowake, sections[isp], op[isp])[1]\n        Res_wake[i] = CCBlade.residual(phi[i].* pi/180, rotor_wake, sections[isp], op[isp])[1]\n    end\n\n    figure()\n    plot(phi,Res_nowake)\n    plot(phi,Res_wake)\n    plot(out_nowake[isp].phi.* 180/pi, 0.,\"x\")\n    plot(out_wake[isp].phi.* 180/pi, 0.,\"x\")\n    \n    xlabel(L\"\\phi\")\n    ylabel(L\"residual\")\n\n    ylim([-.25,0.5])\n    xlim([-1,5])\n\n    savefig(\"wakeEx1.1_res.svg\") # hide\n\n    nothing # hide","category":"page"},{"location":"wake_model_examples/","page":"Examples using the cylinder wake model","title":"Examples using the cylinder wake model","text":"(Image: ) (Image: )","category":"page"},{"location":"wake_model_examples/#Example-2:-coned-rotor-with-shear-and-tilt","page":"Examples using the cylinder wake model","title":"Example 2: coned rotor with shear and tilt","text":"","category":"section"},{"location":"wake_model_examples/","page":"Examples using the cylinder wake model","title":"Examples using the cylinder wake model","text":"TODO","category":"page"},{"location":"wake_model_examples/#Example-3:-influence-of-yaw","page":"Examples using the cylinder wake model","title":"Example 3: influence of yaw","text":"","category":"section"},{"location":"wake_model_examples/","page":"Examples using the cylinder wake model","title":"Examples using the cylinder wake model","text":"TODO","category":"page"},{"location":"wake_model_examples/#Example-4:-rotor-with-curved-blades","page":"Examples using the cylinder wake model","title":"Example 4: rotor with curved blades","text":"","category":"section"},{"location":"wake_model_examples/","page":"Examples using the cylinder wake model","title":"Examples using the cylinder wake model","text":"TODO","category":"page"},{"location":"theory/#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Theory is detailed in the publication below and a preprint is available here.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Ning, A., Using Blade Element Momentum Methods with Gradient-Based Design Optimization, Structural and Multidisciplinary Optimization, May 2021.","category":"page"},{"location":"wake_model/#Cylinder-wake-model","page":"Wake model","title":"Cylinder wake model","text":"","category":"section"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"We explain how the cylinder wake model is implemented, and we go over the related modifications in the BEM equations.","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"The purpose of this model is to account for radial flow components, and wake skewness. It can be seen as a generalization of other skewed inflow models such as Pitt & Peters, etc. It is based on a cylindrical representation of the wake, as proposed in [Branlard2015] and [Branlard2016]. As argued in [Crawford2006] and [McWilliams2011], the so-derived BEM has improved accuracy for cases with precone and yaw.","category":"page"},{"location":"wake_model/#Induced-velocities","page":"Wake model","title":"Induced velocities","text":"","category":"section"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"note: Note\nFor details on this section, see [Branlard2016]. Illustrations from this section are also mostly taken from there.","category":"page"},{"location":"wake_model/#Principle","page":"Wake model","title":"Principle","text":"","category":"section"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"The wake geometry of the wake is assumed fixed. It is composed of a semi-inifinite outer cylindrical vortex sheet of radius R, a disk vortex sheet at the location of the rotor and a semi-infinite root vortex filament. The disk has a purely radial vorticity component, and the outer cylindrical sheet has two separate components: axial and tangential.  The vorticity/circulation in those elements is assumed uniformly constant.","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"The indice r refers to the root axial vorticity, b to the bound vorticity on the disk, t to the tangential vorticity in the outer sheet, and l to the axial/longitudinal vorticity in the outer sheet.","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"(Image: )","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"All the vortex instensity components in the different wake objects are related, see next section. For now, let us assume that they are all linearly dependant on gamma_t. This will be convenient since the usual result from the Biot-Savart law is u_x_0 = gamma_t  2, where u_x_0 is the velocity induced at the edge of a straight circular cylinder with uniform tangential vorticity.","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"To include yaw, we allow the wake to be skewed by an angle chi with respect to the rotor frame of reference. Mind the coordinate system attached to the rotor, which does not follow wind turbine conventions!","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"(Image: )","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"In those conditions, we can compute the velocity induced by each of the vortex component (for a given gamma_t) from each object on a point located on the rotor disk.  This comes down to numerically integrate [Branlard2016, eq.5-8], which we do with Gauss-Legendre quadrature.","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"For example, we set chi = 30^o, gamma_t = -1. The axial velocity (z) induced by the tangential component of the outer vorticity cylinder (t) is u_zt:","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"(Image: )","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"The radial and tangential velocities induced by the tangential component of the outer vorticity cylinder (resp. u_rt, u_psit) are also shown:","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"(Image: )","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"Similarly, the axial velocity induced by the root vortex u_zr (assuming Gamma_r = -1):","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"(Image: )","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"note: Note\nThe dominating  wake component on the induced velocities are those from the tangential vorticity in the outer cylinder, and the axial vorticity in the root vortex, see [Branlard2016, sect.4].","category":"page"},{"location":"wake_model/#Expressions-of-the-induced-velocities-from-the-respective-wake-components","page":"Wake model","title":"Expressions of the induced velocities from the respective wake components","text":"","category":"section"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"From here on, we resume with standard wind-turbine conventions regarding frame of references.","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"Crucially, we still assume the independance of annular sections on the rotor (even though it is provably doubtful) we want to keep a simple numerical method. A formal motivation for this is given in [Branlard2015, sect.4.3] for the case of the straight cylinder wake model. In practice this means the following: every anular section has an associated bound vorticity gamma_b that corresponds to the circulation of the blades at that location. Neglecting the circulation of all the other anular sections, the vorticity in all other wake components may be expressed as a function of the bound vorticity, by the Kelvin theorem (circulation is conserved). We thus have (see also [Branlard2016, 2.3]):","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"Gamma_r = -2pi r gamma_b ","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"gamma_l = -fracGamma_r2pi R","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"gamma_t = -fracGamma_rh  cos(chi)","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"where h is the pitch of the helix formed by the tangential and axial components in the outer vortex sheet. At high TSR (lambda), the latter can be evaluated as h=fracpi Rlambda (1 + sqrt1-C_T) (see [Branlard2015, sect.4] and refs therein).","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"As mentioned before, we rather express the various vorticity/circulations as a function of gamma_t:","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"Gamma_r = -gamma_t frachcoschi ","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"gamma_l = fracgamma_t2pi R frachcoschi ","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"gamma_b = fracgamma_t2pi r frachcoschi ","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"Note that all are linear in gamma_t.","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"warning: Warning\nIn the following, we neglect the influence of the bound vorticity on the velocity measured in the rotor plane. This is mainly to decouple the BEM computation from each blade.","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"The axial, tangential and radial induced velocities at the rotor are","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"u_x = u_xt + u_xr + u_xl oversetDelta= I_x gamma_t","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"u_psi = u_psit + u_psir + u_psil oversetDelta= I_psi gamma_t","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"u_r = u_rt + u_rl oversetDelta= I_r gamma_t","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"Notice that the root vortex never induces radial velocity.","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"The I factors are the previously-mentioned integrals that only depend on geometric factors: (rRpsixchi). In practice, in spite of the blade bending and/or (pre)cone, we always evaluate I at x=0. The reason is that the head of the cylinder model is flat and passes through the rotor hub. Hence, it makes more sense to evaluate induced velocity in the rotor plane. We also neglect the influence of the tilt angle on I.","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"danger: Danger\nTODO: for completeness, write the expressions for I_cdot, and be careful with the change of convention between Branlart and standard WT.","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"In the far wake, the induced velocities are","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"u_x_2 = gamma_t","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"u_psi_2 = left u_psir right_xrightarrowinfty = fracGamma_r2pi r coschi cosTheta  oversetDelta= I_psi_2 gamma_t","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"u_r_2 = 0","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"since u_psil is uniformly zero inside the cylinder wake, and there is no tangential velocity induced by the tangential vorticity component.","category":"page"},{"location":"wake_model/#Usage-in-the-BEM","page":"Wake model","title":"Usage in the BEM","text":"","category":"section"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"We showed that the induced veloctities at the rotor can be expressed as","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"beginaligned\nu_x = I_x gamma_t \nu_psi = I_psi gamma_t \nu_r = I_r gamma_t \nendaligned","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"where, again, the I factors are computed numerically and do not depend on gamma","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"For the sequel, it will be convenient to define epsilon factors. The conventional result generally used in BEM corresponds to epsilon_x= epsilon_psi =1. Conventional BEM also neglects u_r (i.e., epsilon_r=0 ).","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"beginaligned\nu_x epsilon_x = gamma_t  2 \nu_psi epsilon_psi = u_psi_2  2  \nu_r = epsilon_r u_x \nendaligned","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"such that","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"beginaligned\nepsilon_x = 1  (2 I_x) \nepsilon_psi = frac12 fracI_psi_2I_psi  \nepsilon_r = I_r  I_x \nendaligned","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"note: Note\nRelation to other skewed wake modelsAs noted in [Branlard2016], the cylinder wake model can be seen as a generalization of other models that have been proposed to treat yaw. The relation between these models and the current one is established by noticing that the axial induced velocity has the form of the model proposed by Glauert:u_x = fracgamma_t2 (1 + K sinpsi)where K has an expression that depends on the model.For the Coleman et al. model for instance, K_textrmPittPeters = fracrR tan(chi2)The Pitt & Peters model gives, K_textrmColeman = fracrR frac15pi32 tan(chi2)although some authors proposed to use a factor 15pi64 instead (see [Ning2015]). Other models can be found in the litterature (see e.g. [Micallef2016])In the present model, u_x is influenced by the various component of vorticity in the wake (see the above equation u_x = u_xt + u_xr + u_xl). In that sense it is more general. However, we can establish a link with the above simple models if we we consider only the velocity induced by the tangential component of the tip vorticity (neglecting u_xr and u_xl).  Indeed, the velocity induced by the tangential vorticity in the cylinder also has the form u_xt = fracgamma_t2 (1 + K_xt sinpsi), where K_xt takes the form of an integral that needs to be computed numerically. Furthermore, we can show that the linearization of K_xt leads us to recover the exact same expression for K as the Coleman et al. model.","category":"page"},{"location":"wake_model/#Adapted-BEM-equations","page":"Wake model","title":"Adapted BEM equations","text":"","category":"section"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"We re-develop the BEM equations following the same logic as in [Ning2021], but for the general case of a turbine with yaw and non-straight/preconed blades. We make use of the definitions of the epsilon factors, and the standard definition of the induction factors:","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"a = fracu_xV_x quad a = fracu_psiV_y","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"We refer the interested reader to Branlard2015, sect.4.2 for a formal explanation of the relation between the BEM theory and the vortex-induced velocity.","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"warning: Warning\nThe sign conventions used here may depend on the type of operation (turbine/propeller). We follow the same definitions as in [Ning2021]. ","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"We account for a yaw angle chi_0. At a given radial station r measured along the blade, the local coning and sweep angles are beta and s, and the distance to the rotor shaft is r_a approx z_a (see figures below). ","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"The main idea behind this development is to relate the local forces on the blades (which depend on the 2D aerodynamics expressed in a plane normal to the deflected blade) to the updated  momentum equations. The axial momentum (both axial and angular) is expressed in the direction normal to the rotor plane (see reference frames hereafter).","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"note: Note\nGenerally, the yaw angle chi_0 is smaller than the skew angle chi. See references in [Branlard2016, sect.2.1] for relations between them. If we neglect the tilt angle, we can simply use the relation from Burton's Wind Energy handbook [Ning2015, eq.31]chi = (06 a + 1) chi_0danger: Danger\n:warning: should clarify if a = u_xV_infty or a = u_x_2V_infty in that formula(Image: )","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"note: Note\nNotations: V_i are external velocities (from the inflow and the rotation); u_i are wake-induced velocities; U_i are the sum of V_i and u_i.","category":"page"},{"location":"wake_model/#Reference-frames","page":"Wake model","title":"Reference frames","text":"","category":"section"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"We present some figures modified from [Ning2015].","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"Looking at the turbine from a multi-body perspective, the chaining between frames and corresponding rotations and angle is the following:","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"(Image: )","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"For the purpose of the present BEM implementation however, we introduce an approximation that corresponds to slightly altering that order, as follows:","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"(Image: )","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"What this approximation does is that it considers that the pitch actuation results in uniformly modifying the airfoil pitch angle along the blade span, as if it was locally twisted instead of being 'rigidly' rotated at the root. This essentially affects deformed/non-straight blades, and does not change anything  for straight blades. We will see hereafter that this assumption his crucial in decoupling tangential and axial inductions, resulting in equations that can be solved sequentially.","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"Rotor-related frame:","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"(Image: )","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"We will express the momentum in the direction normal to the rotor plane (after yaw and tilt, before coning and sweep). That is where our xyz equiv x_azy_azz_az coordinate system is defined. ","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"note: Note\nDefinitions (caution: tilt and precone are inverted w.r.t. AeroDyn!):positive tilt results in rotor facing upwards (upwind turbines have Theta  0)\npositive precone results in blade leaning forward (upwind turbines have beta_0  0)\npositive yaw results in the wind coming from your right if you sit on top of the hub facing the winddanger: Danger\nTODO: check yaw convention throughout the code(Hence, for psi=0, beta=-beta_0 gives the same results forall beta)","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"Blade related-frames:","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"The blade root frame is handy because we expect that any structural code will output the blade deformation in those coordinates. For a straight blade, we will have z_a= r and x_a = y_a = 0.","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"(Image: )","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"Note that beta is the local coning angle (that accounts only for flapwise bending). ","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"note: Note\nAnother potentially useful assumption is sweep through shearing that replaces rt with rt. This consists in neglecting the change of orientation of the blade related to sweep, leaving r parallel to z_a.danger: Danger\nNeed to assess the necessity of this assumption.","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"note: Note\nDefinitionspositive conicity is a positive rotation about y, that is downwards (i.e., opposed to the precone!)\npositive sweep is a positive rotation about x","category":"page"},{"location":"wake_model/#External-velocity-at-the-blade","page":"Wake model","title":"External velocity at the blade","text":"","category":"section"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"Given the position of a blade segment in the rotor plane parametrized by y_az=y_a z_az = z_a cos(beta_0), and rotor info psiThetachi_0, one can obtain the componnents of the upstream velocity and rotational velocity in the rotor (x=x_azy=y_azz=z_az) frame. ","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"beginaligned\nV_x = V_infty cos(chi_0) cos(Theta) \nV_y = V_infty (cos(chi_0) sin(Theta) sin(psi) - sin(chi_0) cos(psi) ) + Omega cos(beta_0) z_a \nV_z = V_infty (cos(chi_0) sin(Theta) cos(psi) + sin(chi_0) sin(psi) ) - Omega y_a\nendaligned","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"This is essentially Eq.28 in [Ning2015], but expressing the velocities in the frame before precone (and not after), since we are interested in velocities in the rotor plane. V_infty may include a dependency on z_i to account for shear.","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"warning: Warning\nTheoretically, y_a should be accounted for in the above expression since it may introduce components of rotational velocity in both V_yV_z. We choose to neglect that effect since the sweep deflection is likely small.danger: Danger\nTODO: CHECK THAT WE NEED THIS, because currently it is coded in the op routine  ","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"Note that in the basic BEM, induction factors are defined with respect to V_infty and ROmega respectively. Since all unsteady effects are here neglected, we express the BEM equations by assuming we can replace these with the instantaneous velocities V_xV_y.","category":"page"},{"location":"wake_model/#Rotor-mass-flow","page":"Wake model","title":"Rotor mass flow","text":"","category":"section"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"For an anular section A_a = 2 pi r_a dr, assuming local conditions (velocities) apply to the entire annulus:","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"dotm = rho A_a (V_x + u_x ) = rho V_x A_a (1 + a)","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"note: Note\nSome authors keep the definition of a = fracu_xV_infty, which leads to dotm = rho A_a V_infty (cos(chi_0) cos(Theta) + a )and similar expressions in the sequel. warning: Warning\nIs there really a reason to favor one or the other approach?    ","category":"page"},{"location":"wake_model/#Thrust-coefficient","page":"Wake model","title":"Thrust coefficient","text":"","category":"section"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"With the Prandtl loss function F:","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"T = frac12 rho V_x^2 A_a C_T = dotm Delta V F","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"where the Delta is taken between far-field velocities measured normally to the rotor plane","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"Delta V = ( V_infty cos(chi_0) - (V_infty cos(chi_0) - gamma_t cos(chi)) ) cos(Theta) = gamma_t cos(chi) cos(Theta) = 2 u_x epsilon_x cos(chi) cos(Theta)","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"Thus,","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"C_T = 4 a (1 + a) epsilon_x cos(chi) cos(Theta) F","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"warning: Warning\nThe latter expression is different from that proposed in [McWilliams2011]: C_T = 4 a (cos(chi_0) + epsilon_x a)  epsilon_x.  It is also different from Glauert's theory, see in [Ning2015]: C_T = 4 sqrt 1 + a (2 cos(chi_0) + a) a F. All of them collapse to the the propeller-brake/momentum region formula with no yaw C_T = 4 (1+a) a F [Ning2021].","category":"page"},{"location":"wake_model/#Torque-coefficient","page":"Wake model","title":"Torque coefficient","text":"","category":"section"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"Recalling that u_psi_2 is the far field tangential velocity in the cylinder,","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"Q = frac12 rho V_x^2 A_a r_a C_Q = dotm r_a u_psi_2 F = dotm r_a 2 u_psi epsilon_psi F","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"C_Q = 4 a (1 + a) epsilon_psi V_y  V_x F","category":"page"},{"location":"wake_model/#Airfoil-aerodynamics","page":"Wake model","title":"Airfoil aerodynamics","text":"","category":"section"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"The 2-D aerodynamics has to be expressed in a plane normal to the blade axis, rotated by the angle beta and s with respect to the rotor reference plane. In fact, the blade is allowed to deflect, and may have a local coning and sweep angle. The forces on the airfoil are transferred to the rotor reference plane so as to express the axial and angular momentum in that reference plane.","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"(Image: )","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"By definition, tan(phi) = fracU_nU_t that we can rewrite","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"frac sin(phi)  U_n  - frac cos(phi)  U_t  = 0","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"We need two things to happen: obtain the velocities U_nU_t in the local blade frame, and transform the forces expressed in the local blade frame to the rotor frame. ","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"(Image: )","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"The local 2-D aerodynamics  yields forces parallel to the normal and tangential direction:","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"beginaligned\nf_n = frac12 rho W^2 c c_n(phi) dr\nf_t = frac12 rho W^2 c c_t(phi) dr\nendaligned","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"and we need to express these forces in the coordinate system associated with the rotor disk","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"beginaligned\nf_x = frac12 rho W^2 c c_x(c_nc_tbeta_0 theta_0 betas) dr \nf_y = frac12 rho W^2 c c_y(c_nc_tbeta_0 theta_0 betas) dr\nendaligned","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"where c_xc_y are coordinate transformations (blade to rotor).","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"Similarly, we need to express W U_n U_t as a function of the velocities in the rotor c.s.:","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"U_n U_t U_r^T = A U_x U_y U_z ^T = A V_x (1+a) V_y (1-a) V_z + V_x a epsilon_r^T","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"where A is the rotation matrix between the rotor frame and the local blade frame (that includes precone beta_0,  pitchtheta_0, coning beta, sweep s):","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"A = left(beginmatrix\n 1                 0                \n 0                 cos s         sin s \n 0                -sin s         cos s\nendmatrixright) \nleft(beginmatrix\n cos beta        0                 -sin beta\n 0                 1                  0 \n sin beta        0                  cos beta\nendmatrixright) \nleft(beginmatrix\n cos theta_0        sin theta_0     0\n-sin theta_0        cos theta_0     0 \n 0                    0                 1\nendmatrixright) \nleft(beginmatrix\n cos beta_0        0                 -sin beta_0\n 0                   1                  0 \n sin beta_0        0                  cos beta_0 \nendmatrixright)","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"warning: Warning\nIn theory, a is related to the tangential velocity component V_psi which may slightly differ  from V_y  when the blade center line has a non-zero y in the azimuthal frame (i.e., the blade is not purely radial). However, we here neglect this effect, assuming that V_psi = V_y and that the rotational induced velocity is similarly obtained u_y = u_psi = V_y a. This is the main reason for invoking the previously mentioned hypothesis of sweep though shear.","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"The full expression of the total velocities in the airfoil frame reads","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"leftbeginmatrix \nU_n  \nU_t\nendmatrixright \nleft(beginmatrix\ncos beta  cos theta_0 cos beta_0 - sin beta sin beta_0        cos beta sin theta_0          -cos beta cos theta_0 sin beta_0 - sin beta cos beta_0\n    \nendmatrixright)\nleftbeginmatrix \nV_x (1+a)  \nV_y (1-a)\nV_z + V_x a epsilon_r\nendmatrixright","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"note: Note\nWhat we obtain at this stage is a system where we can hardly obtain an expression of U_n or U_t as a function of only a or a. This will prevent the expression of the residual under the form of a single equation, as a function of phi.  However, we notice that if we neglect A_12, the expression of U_n does not depend on a which effectively decouples the system. Similarly, we may want to have that U_t only depends on V_y.  We will thus arbitrarily set sin theta_0 = 0, which achieves both objectives.We further neglect the sweep angle in this coordinate transformation, to simplify the expressions and because sweep angle is generally small.warning: Warning\nFor consistency, we also neglect the sweep in c_xc_y..","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"With these assumtions, we obtain","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"beginaligned\nU_n = (cos beta  cos theta_0 cos beta_0 - sin beta sin beta_0) V_x ( 1 + a) - (cos beta cos theta_0 sin beta_0 + sin beta cos beta_0) ( V_z + V_x a epsilon_r) \nU_t =  cos theta_0 V_y  (1-a)\nendaligned","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"Thus,","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"beginaligned\nU_n = p_1 V_x ( 1 + a) + p_2 ( V_z + V_x a epsilon_r) \nU_t = p_3 V_y  (1-a)\nendaligned","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"note: Note\nWith unsteady flexible blades, the displacement velocity of the blades expressed in the airfoil frame, v_n v_t, may be added directly here:beginaligned\nU_n =  - v_n \nU_t =  - v_t\nendalignedThis only slightly modifies the BEM equations hereunder.danger: Danger\nMaybe more than slightly... Consider doing a (V_x+v_x) = u_x, i.e. add deflection velocity to the external velocities?","category":"page"},{"location":"wake_model/#BEM-equations","page":"Wake model","title":"BEM equations","text":"","category":"section"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"The 1-equation residual reads:","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"R(phi) = frac sin(phi)  U_n  - frac cos(phi)  U_t  = 0","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"where the expressions for U_n U_t were given at the bottom of the previous section, as a function of the unknown inductions. Also, W = fracU_nsin phi = fracU_tcos phi.","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"We obtain an expression for aa as a function of phi by equating the momentum equations and the local 2D aerodynamics (recast in terms of local thrust coef.), ","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"C_T = 4 a (1 + a) epsilon_x cos(chi) cos(Theta) F = fracB c 2 pi z_a fracW^2V_x^2 c_x","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"C_Q = 4 a (1 + a) epsilon_psi V_y  V_x F = fracB c 2 pi z_a fracW^2V_x^2 c_y","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"For the thrust coefficient, this leads to:","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"fraca (1 + a)( (p_1 V_x + p_2 V_z) + (p_1 + p_2 epsilon_r) V_x a )^2 = frac1 epsilon_x cos(chi) cos(Theta)F V_x^2 sin^2phi fracB c c_x8 pi z_a oversetDelta= kappa","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"We can then solve for a:","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"fraca(1+a)(b_1 + b_2 a)^2 = kappa ","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"a = frac-2 b_1 b_2 kappa +1 pm sqrt4 b_1^2 kappa - b_1 b_2 kappa + 12(b_2^2 kappa -1) quad textrmwith pm b_2 sqrt4 b_1^2 kappa - b_1 b_2 kappa + 1 - 2 b_1 + b_2 ne 0","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"warning: Warning\nThere are two roots to this equation. Hopefully, one can be ruled out from physics considerations. This has to be verified, though.","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"Knowing a, and using the various expressions for W, the tangential equilibrium yields ...","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"fraca1-a = fracb_1 + b_2 aV_x (1+a)  underbracefracp_34epsilon_psi F sinphi cosphi fracB c c_y 2pi z_a _oversetDelta= kappa","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"that we can easily invert for a \"as usual\".","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":":tada: ","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"note: Note\nRelation with the original BEM The main difference to remember is that, with the present expression of the BEM equation, everything is written in the blade azimuthal frame whereas the original implementation considered the thrust in the blade root frame (i.e. normal to the blade and not normal to the rotor). We However, by considering the following changes, the present implementation reverts to the original CCBlade implementation:the wake epsilon factor take their original value: epsilon_x= epsilon_psi = 1 epsilon_r = 0\ntilt and yaw do not enter the in kappakappa: cos(Theta) = cos(chi) = 1, \nsigma_p = B*chord/(2.0*pi*r) where r does not account for precone. \nthe velocity normal to the blade is Vx = (cos(precone) * Vx_az - sin(precone) * Vz_az). Everywhere else, we set p1 = 1, p2 = 0 such that cn = cx, ct = cy, b2 = b1 = Vx\nthe local thrust (Np) is rotated by the precone angle before the integration of the rotor thrust.For backward compatibility, this remains the default behavior of the code. The new implementation is turned on only when passing wakeCyl = true to the rotor object.","category":"page"},{"location":"wake_model/#Summary-of-the-assumptions","page":"Wake model","title":"Summary of the assumptions","text":"","category":"section"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"we neglect the influence of the bound vortices of the other blades on the current blade. This is valid if all the blade have the same circulation, which is not exactly the case in yaw or with shear.\nwe neglect the influence of the longitudinal vorticity components of the tip cylinder on the velocity measured normal to the disk \nwe still assume the independance of each annular section (theoretically only valid for no yaw, no cone, and high TSR  [Branlard2015]). Otherwise, the determination of the axial induction at a given radial station would depend on all the other sations, requiring to solve a large system of equations (see also [Branlard2015, sect.4.3]). \nthe wake geometry is assumed as explained above: no wake expansion, plus the wake vorticity is only shed at the blade root and the blade tip.    The wake expansion could be taken into account by a discretization in the axial direction [Crawford2006] and iterations... But anyway, the wake expansion results in an increase of induction near the tip, which is overtaken by the Prandtl tip correction.\nthe evaluation of the pitch of the helix h assumes high TSR\nwe neglect the blade flap/coning angle when evaluating the epsilon factors. The reason is that the cylider wake model is centered on the rotor hub, and does not come forward when the blades bend.\nwe neglect the wake redirection by the tilt angle (i.e., the wake is parallel to the ground). Even more, we consider that the integrals I in the computation of the induced velocities do not depend on Theta.","category":"page"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"we neglect the sweep angle in the computation of the normal and tangential velocities (this angle should be small anyway) This assumption might be unnecessary.","category":"page"},{"location":"wake_model/#TODO","page":"Wake model","title":"TODO","text":"","category":"section"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"[ ] write the expressions for I\n[ ] checks sign consistency between wake model and BEM: psi, yaw, tilt\n[ ] check sign consistency of a, etc. with Ning2021\n[ ] shall we define a=ux/Uinf or a=ux/Ux ?\n[ ] smoothly connect to the high induction model. Treat the particular cases ofsome missing velocities\n[ ] would it be better to pre-evaluate epsilon and look it up during BEM computation, or can we just keep re-evaluating it on the run?\n[ ] update openmdao/python/ccblade \n[ ] test the whole method with con/swp.","category":"page"},{"location":"wake_model/#References","page":"Wake model","title":"References","text":"","category":"section"},{"location":"wake_model/","page":"Wake model","title":"Wake model","text":"[Branlard2016] Branlard, E. and Gaunaa, M. Cylindrical vortex wake model: skewed cylinder, application to yawed or tilted rotors. Wind Energy, 2016.\n[Branlard2015] Branlard, E. and Gaunaa, M. Cylindrical vortex wake model: right cylinder. Wind Energy, 2015.\n[Crawford2006] C. Crawford. Re-examining the precepts of the blade element momentum theory for coning rotors. Wind Energy, 9(5):457478, 2006.\n[McWilliams2011] M. McWilliam, S. Lawton, S. Cline, and C. Crawford. A corrected blade element momentum method for simulating wind turbines in yawed flow. In 49th AIAA Aerospace Sciences Meeting including the New Horizons Forum and Aerospace Exposition, 2011.\n[Micallef2016] D. Micallef and T. Sant. A review of wind turbine yaw aerodynamics. Wind Turbines-Design, Control and Applications, 2016.\n[Ning2015] A. Ning, G. Hayman, R. Damiani, and J. M. Jonkman. Development and validation of a new blade element momentum skewed-wake model within aerodyn. In 33rd Wind Energy Symposium, 2015.\n[Ning2021] Ning, A., Using Blade Element Momentum Methods with Gradient-Based Design Optimization, Structural and Multidisciplinary Optimization, May 2021.","category":"page"},{"location":"reference/#Reference","page":"API Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"This section describes the API in more detail.","category":"page"},{"location":"reference/#Input-Structs","page":"API Reference","title":"Input Structs","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"The rotor object is defined as follows.","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Rotor","category":"page"},{"location":"reference/#CCBlade.Rotor","page":"API Reference","title":"CCBlade.Rotor","text":"Rotor(Rhub, Rtip, B; precone=0.0, tilt=0.0, turbine=false, \n    mach=nothing, re=nothing, rotation=nothing, tip=PrandtlTipHub(), wakeCyl=false)\n\nParameters defining the rotor (apply to all sections).  \n\nArguments\n\nRhub::Float64: hub radius (along blade length)\nRtip::Float64: tip radius (along blade length)\nB::Int64: number of blades\nprecone::Float64: precone angle\n\nturbine::Bool: true if using wind turbine conventions\nmach::MachCorrection: correction method for Mach number\nre::ReCorrection: correction method for Reynolds number\nrotation::RotationCorrection: correction method for blade rotation\ntip::TipCorrection: correction method for hub/tip loss\nwakeCyl::Bool: true to use the cylinder wake model\n\n\n\n\n\n","category":"type"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"The precone angle is shown below (commonly used with wind turbines, less so with propellers). Phi is positive as shown.","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"(Image: precone)","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"If there is precone then the Rhub and Rtip dimensions correspond to the length along the blade (instead of the radius from the center of rotation).  That way when precone is changed, the blade just rotates instead of shearing as is more common.  The turbine parameter is used for wind turbines, as discussed in Wind Turbine Operation.  The remaining options are for airfoil (and tip loss) corrections and are discussed in Airfoil (and Tip) Corrections. ","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"The Section object is defined as follows:","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Section","category":"page"},{"location":"reference/#CCBlade.Section","page":"API Reference","title":"CCBlade.Section","text":"Section(r, chord, theta, af)\nSection(chord, theta, af, x_az, y_az, z_az, coning, sweep)\nSection(chord, theta, af, precone, x_def, y_def, z_def, coning, sweep)\n\nDefine sectional properties for one station along rotor\n\nArguments\n\nr::Float64: radial location along blade, measured in the blade root frame\nchord::Float64: corresponding local chord length\ntheta::Float64: corresponding twist angle (radians)\naf::Function or AFType: if function form is: cl, cd = af(alpha, Re, Mach)\nx_az::Float64: x location when blade is deflected in the azimuthal frame (m)\ny_az::Float64: y location when blade is deflected in the azimuthal frame (m)\nz_az::Float64: z=radial location when blade is deflected (m)\n\nor \n\nprecone::Float: precone angle (rad)\nx_def::Float64: x location when blade is deflected, in the blade root frame (m)\ny_def::Float64: y location when blade is deflected, in the blade root frame (m)\nz_def::Float64: z location when blade is deflected, in the blade root frame (m)\nconing::Float64: local coning angle w.r.t. blade root at that location, in blade root frame (rad), i.e. lcon>0 for a blade deflected downwind\nsweep::Float64: local sweep angle w.r.t. blade root at that location (rad)\n\n\n\n\n\n","category":"type"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Radius, like the hub and tip radii, follows along the blade.  Note that we usually only specify interior r points (e.g., strict inequalities for Rhub < r < Rtip).  However, CCBlade will allow you to specify points all the way to r = Rtip and/or r = Rhub, but because the loads are always zero at the hub/tip, the computation is bypassed for efficiency.  The thrust/torque integration always extrapolates to zero loads at the tip so there is no benefit to including the ends, however there is no harm either. ","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Positive twist is shown below.  ","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"(Image: inflow1)","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Airfoils are either a function as noted in the docstring, or a subtype of AFType, which in discussed in more detail in Airfoil Evaluation. ","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"The remaining input is the operating point:","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"OperatingPoint","category":"page"},{"location":"reference/#CCBlade.OperatingPoint","page":"API Reference","title":"CCBlade.OperatingPoint","text":"OperatingPoint(Vx, Vy, Omega, rho)\nOperatingPoint(Vx, Vy, Vz, Omega, rho; pitch=0.0, mu=1.0, asound=1.0)\n\nOperation point for a rotor.   The x direction is the axial direction, and y direction is the tangential direction in the rotor plane.   See Documentation for more detail on coordinate systems. #TODO: expand/rewrite Vx and Vy vary radially at same locations as r in the rotor definition.\n\nArguments\n\nVx::Float64: velocity in x-direction along blade\nVy::Float64: velocity in y-direction along blade\nVz::Float64: velocity in z-direction along blade\nVhub::Float64: upstream velocity\nOmega::Float64: rotation rate\nrho::Float64: fluid density\npitch::Float64: pitch angle (radians)\nmu::Float64: fluid dynamic viscosity (unused if Re not included in airfoil data)\nasound::Float64: fluid speed of sound (unused if Mach not included in airfoil data)\n\n\n\n\n\n","category":"type"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"The inflow velocities V_x and V_y are seen in the figure above.  This allows to user to specify a completely general input, but usually these aren't specified directly.  Rather convenience functions are used to define these velocities across the blade (discussed below).  Dynamic viscosity is only need if the airfoil data contains multiple Reynolds number.  The speed of sound is only needed if the airfoil data contains multiple Mach numbers.  Pitch twists the entire blade in the same positive direction as twist.","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"A simple propeller would have V_x = V_infty and V_y = Omega r.  That's essentially what the simple_op convenence function provides (with the addition of accounting for precone).  ","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"simple_op","category":"page"},{"location":"reference/#CCBlade.simple_op","page":"API Reference","title":"CCBlade.simple_op","text":"simple_op(Vinf, Omega, r, rho; pitch=0.0, mu=1.0, asound=1.0, precone=0.0)\n\nUniform inflow through rotor.  Returns an OperatingPoint object.\n\nArguments\n\nVinf::Float: freestream speed (m/s)\nOmega::Float: rotation speed (rad/s)\nr::Float: radial location where inflow is computed (m)\nrho::Float: air density (kg/m^3)\npitch::Float: pitch angle (rad)\nmu::Float: air viscosity (Pa * s)\nasounnd::Float: air speed of sound (m/s)\nprecone::Float: precone angle (rad)\n\n\n\n\n\n","category":"function"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"For wind turbines, a convenience function is provided windturbine_op that also includes yaw, tilt, azimuth, hub height, and a shear exponent.  ","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"windturbine_op","category":"page"},{"location":"reference/#CCBlade.windturbine_op","page":"API Reference","title":"CCBlade.windturbine_op","text":"windturbine_op(Vhub, Omega, pitch, r, precone, yaw, tilt, azimuth, hubHt, shearExp, rho, mu=1.0, asound=1.0)\n\nCompute relative wind velocity components along a straight blade accounting for inflow conditions and orientation of turbine.  See Documentation for angle definitions.\n\nArguments\n\nVhub::Float64: freestream speed at hub (m/s)\nOmega::Float64: rotation speed (rad/s)\npitch::Float64: pitch angle (rad)\nr::Float64: radial location along the blade axis (in the blade root frame) where inflow is computed (m)\nprecone::Float64: precone angle (rad)\nyaw::Float64: yaw angle (rad)\ntilt::Float64: tilt angle (rad)\nazimuth::Float64: azimuth angle to evaluate at (rad)\nhubHt::Float64: hub height (m) - used for shear\nshearExp::Float64: power law shear exponent\nrho::Float64: air density (kg/m^3)\nmu::Float64: air viscosity (Pa * s)\nasound::Float64: air speed of sound (m/s)\n\n\n\n\n\n","category":"function"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"(Image: )","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"To account for the velocity change across the hub face we compute the height of each blade location relative to the hub using coordinate transformations (where Phi is the precone angle):","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"  z_h = r cosPhi cospsi cosTheta + r sinPhisinTheta","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"then apply the shear exponent (alpha):","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"  V_shear = V_hub left(1 + fracz_hH_hub right)^alpha","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"where H_hub is the hub height.  Finally, we can compute the x- and y-components of velocity with additional coordinate transformations:","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"beginaligned\nV_x = V_shear ((cos gamma sin Theta cos psi + sin gamma sin psi)sin Phi + cos gamma cos Theta cos Phi)\nV_y = V_shear (cos gamma sin Thetasin psi - sin gamma cos psi) + Omega r cosPhi\nendaligned","category":"page"},{"location":"reference/#Output-Struct","page":"API Reference","title":"Output Struct","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"The full list of Outputs is as follows:","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Outputs","category":"page"},{"location":"reference/#CCBlade.Outputs","page":"API Reference","title":"CCBlade.Outputs","text":"Outputs(Np, Tp, a, ap, u, v, phi, alpha, W, cl, cd, cn, ct, F, G)\n\nOutputs from the BEM solver along the radius.\n\nArguments\n\nNp::Float64: normal force per unit length\nTp::Float64: tangential force per unit length\na::Float64: axial induction factor\nap::Float64: tangential induction factor\nu::Float64: axial induced velocity\nv::Float64: tangential induced velocity\nphi::Float64: inflow angle\nalpha::Float64: angle of attack\nW::Float64: inflow velocity\ncl::Float64: lift coefficient\ncd::Float64: drag coefficient\ncn::Float64: normal force coefficient\nct::Float64: tangential force coefficient\nF::Float64: hub/tip loss correction\nG::Float64: effective hub/tip loss correction for induced velocities: u = Vx * a * G, v = Vy * ap * G\n\n\n\n\n\n","category":"type"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Most of these parameters are defined in the figure below.  The variables Np and Tp (where p is short for prime, as in a force per unit length) are in the cn and ct directions respectively.","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"(Image: inflow2)","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"When using broadcasting to retrieve multiple outputs as once (as would be commonly done for multiple sections along a blade) the return type is an array of structs.  However, the dot notation is overloaded so that the outputs can be accessed as if it was a struct of arrays (e.g., outputs.Np).  This was shown in the introductory tutorial.","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"One subtle notes regarding the way the tip-loss factor works.  The BEM methodology applies hub/tip losses to the loads rather than to the velocities.  This is the most common way to implement a BEM, but it means that the raw velocities may be misleading as they do not contain any hub/tip loss corrections.  To fix this we compute the effective hub/tip losses that would produce the same thrust/torque.  In other words: C_T = 4 a (1 + a) F = 4 a G (1 + a G) We solve this for G, and multiply it against the returned wake velocities u and v (but not the induction factors).  Doing so allows us to return consistent values for the wake velocities, which may be of interest when computing interactions between rotor wakes and other objects.","category":"page"},{"location":"reference/#Solve","page":"API Reference","title":"Solve","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Solve is the main function that takes in the three input structs (Rotor, Section, OperatingPoint) and returns the output struct (Outputs).  Often broadcasting is used to call this function at multiple sections, or multiple sections and multiple operating points.","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"solve","category":"page"},{"location":"reference/#CCBlade.solve","page":"API Reference","title":"CCBlade.solve","text":"solve(rotor, section, op)\n\nSolve the BEM equations for given rotor geometry and operating point.\n\nArguments\n\nrotor::Rotor: rotor properties\nsection::Section: section properties\nop::OperatingPoint: operating point\n\nReturns\n\noutputs::Outputs: BEM output data including loads, induction factors, etc.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Integrated-Loads","page":"API Reference","title":"Integrated Loads","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"After solving, the distributed loads can be integrated to provide thrust and torque using the function thrusttorque.","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"thrusttorque(::Any, ::Any, ::Vector{TO}) where TO","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"The method extends to loads to the hub/tip (where the loads go to zero) to capture the small contribution to thrust and torque from the ends of the r vector to Rhub and Rtip.","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"There is also an overloaded version where a matrix of outputs is input for azimuthal averaging (mainly used for wind turbines).","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"thrusttorque(::Any, ::Any, ::Matrix{TO}) where TO","category":"page"},{"location":"reference/#CCBlade.thrusttorque-Union{Tuple{TO}, Tuple{Any, Any, Matrix{TO}}} where TO","page":"API Reference","title":"CCBlade.thrusttorque","text":"thrusttorque(rotor, sections, outputs::Matrix{TO}) where TO\n\nIntegrate the thrust/torque across the blade given an array of output data. Generally used for azimuthal averaging of thrust/torque. outputs[i, j] corresponds to sections[i], azimuth[j].  Integrates across azimuth\n\n\n\n\n\n","category":"method"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Often we want to nondimensionalize the outputs.  The nondimensionalization uses different conventions depending on the name assigned in rotortype.  ","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"nondim","category":"page"},{"location":"reference/#CCBlade.nondim","page":"API Reference","title":"CCBlade.nondim","text":"nondim(T, Q, Vhub, Omega, rho, rotor, rotortype)\n\nNondimensionalize the outputs.\n\nArguments\n\nT::Float64: thrust (N)\nQ::Float64: torque (N-m)\nVhub::Float64: hub speed used in turbine normalization (m/s)\nOmega::Float64: rotation speed used in propeller normalization (rad/s)\nrho::Float64: air density (kg/m^3)\nrotor::Rotor: rotor object\nrotortype::String: normalization type\n\nReturns\n\nif rotortype == \"windturbine\"\n\nCP::Float64: power coefficient\nCT::Float64: thrust coefficient\nCQ::Float64: torque coefficient\n\nif rotortype == \"propeller\"\n\neff::Float64: efficiency\nCT::Float64: thrust coefficient\nCQ::Float64: torque coefficient\n\nif rotortype == \"helicopter\"\n\nFM::Float64: figure of merit\nCT::Float64: thrust coefficient\nCQ or CP::Float64: torque/power coefficient (they are identical)\n\n\n\n\n\n","category":"function"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"For rotortype = \"windturbine\" the following outputs are returned:","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"beginaligned\nC_P = fracPq A V_hub\nC_T = fracTq A\nC_Q = fracQq R_disk A\nendaligned","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"where","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"beginaligned\nR_disk = R_tip cos(textprecone)\nA = pi R_disk^2\nq = frac12rho V_hub^2\nendaligned","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"For type = \"propeller\" the return outputs are:","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"beginaligned\neta = fracT V_hubP\nC_T = fracTrho n^2 D^4\nC_Q = fracQrho n^2 D^5\nendaligned","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"where","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"beginaligned\nD = 2 R_disk\nn = fracOmega2pi\nendaligned","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"For type = \"helicopter\" the return outputs are:","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"beginaligned\nFM = fracC_T^32sqrt2 C_P\nC_T = fracTrho A (Omega R_disk)^2\nC_P = fracPrho A (Omega R_disk)^3\nendaligned","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"note that with this definition C_Q = C_P.","category":"page"},{"location":"reference/#Airfoil-Evaluation","page":"API Reference","title":"Airfoil Evaluation","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"The main airfoil evaluation function is afeval.","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"afeval(::CCBlade.AFType, ::Any, ::Any, ::Any)","category":"page"},{"location":"reference/#CCBlade.afeval-Tuple{AFType, Any, Any, Any}","page":"API Reference","title":"CCBlade.afeval","text":"afeval(af::AFType, alpha, Re, Mach)\n\nEvaluate airfoil aerodynamic performance\n\nArguments\n\naf::AFType or Function: dispatch on AFType or if function call: cl, cd = af(alpha, Re, Mach)\nalpha::Float64: angle of attack in radians\nRe::Float64: Reynolds number\nMach::Float64: Mach number\n\nReturns\n\ncl::Float64: lift coefficient\ncd::Float64: drag coefficient\n\n\n\n\n\n","category":"method"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"It dispatches based on subtypes of AFType or any Function of the form noted in the docstring.  Several subtypes of AFType are implemented.  The first is SimpleAF.","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"SimpleAF","category":"page"},{"location":"reference/#CCBlade.SimpleAF","page":"API Reference","title":"CCBlade.SimpleAF","text":"SimpleAF(m, alpha0, clmax, clmin, cd0, cd2)\n\nA simple parameterized lift and drag curve.  \n\ncl = m (alpha - alpha0) (capped by clmax/clmin)\ncd = cd0 + cd2 * cl^2\n\nArguments\n\nm::Float64: lift curve slope\nalpha0::Float64: zero-lift angle of attack\nclmax::Float64: maximum lift coefficient\nclmin::Float64: minimum lift coefficient\ncd0::Float64: zero lift drag\ncd2::Float64: quadratic drag term\n\n\n\n\n\n","category":"type"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"This form is mostly useful for testing, or really simple analyse.  Next, and perhaps the most common type is AlphaAF. This type takes in arrays of data and creates an Akima spline with variation just in angle of attack.  It can also be initialized from a file (format discussed below).  ","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"AlphaAF","category":"page"},{"location":"reference/#CCBlade.AlphaAF","page":"API Reference","title":"CCBlade.AlphaAF","text":"AlphaAF(alpha, cl, cd, info, Re, Mach)\nAlphaAF(alpha, cl, cd, info, Re=0.0, Mach=0.0)\nAlphaAF(alpha, cl, cd, info=\"CCBlade generated airfoil\", Re=0.0, Mach=0.0)\nAlphaAF(filename::String; radians=true)\n\nAirfoil data that varies with angle of attack.  Data is fit with an Akima spline.\n\nArguments\n\nalpha::Vector{Float64}: angles of attack\ncl::Vector{Float64}: corresponding lift coefficients\ncd::Vector{Float64}: corresponding drag coefficients\ninfo::String: a description of this airfoil data (just informational)\nRe::Float64: Reynolds number data was taken at (just informational)\nMach::Float64: Mach number data was taken at (just informational)\n\nor\n\na file\n\nArguments\n\nfilename::String: name/path of file to read in\nradians::Bool: true if angle of attack in file is given in radians\n\n\n\n\n\n","category":"type"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Similar forms exist for variation with angle of attack and Reynolds number:","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"AlphaReAF","category":"page"},{"location":"reference/#CCBlade.AlphaReAF","page":"API Reference","title":"CCBlade.AlphaReAF","text":"AlphaReAF(alpha, Re, cl, cd, info, Mach)\nAlphaReAF(alpha, Re, cl, cd, info)\nAlphaReAF(alpha, Re, cl, cd)\nread_AlphaReAF(filenames::Vector{String}; radians=true)\n\nAirfoil data that varies with angle of attack and Reynolds number.   Data is fit with a recursive Akima spline.\n\nArguments\n\nalpha::Vector{Float64}: angles of attack\nRe::Vector{Float64}: Reynolds numbers\ncl::Matrix{Float64}: lift coefficients where cl[i, j] corresponds to alpha[i], Re[j]\ncd::Matrix{Float64}: drag coefficients where cd[i, j] corresponds to alpha[i], Re[j]\ninfo::String: a description of this airfoil data (just informational)\nMach::Float64: Mach number data was taken at (just informational)\n\nor\n\nfilenames with one file per Reynolds number.\n\nArguments\n\nfilenames::Vector{String}: name/path of files to read in, each at a different Reynolds number in ascending order\nradians::Bool: true if angle of attack in file is given in radians\n\n\n\n\n\n","category":"type"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"angle of attack and Mach number:","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"AlphaMachAF","category":"page"},{"location":"reference/#CCBlade.AlphaMachAF","page":"API Reference","title":"CCBlade.AlphaMachAF","text":"AlphaMachAF(alpha, Mach, cl, cd, info, Re)\nAlphaMachAF(alpha, Mach, cl, cd, info)\nAlphaMachAF(alpha, Mach, cl, cd)\nAlphaMachAF(filenames::Vector{String}; radians=true)\n\nAirfoil data that varies with angle of attack and Mach number.   Data is fit with a recursive Akima spline.\n\nArguments\n\nalpha::Vector{Float64}: angles of attack\nMach::Vector{Float64}: Mach numbers\ncl::Matrix{Float64}: lift coefficients where cl[i, j] corresponds to alpha[i], Mach[j]\ncd::Matrix{Float64}: drag coefficients where cd[i, j] corresponds to alpha[i], Mach[j]\ninfo::String: a description of this airfoil data (just informational)\nRe::Float64: Reynolds number data was taken at (just informational)\n\nor\n\nfilenames with one file per Mach number.\n\nArguments\n\nfilenames::Vector{String}: name/path of files to read in, each at a different Mach number in ascending order\nradians::Bool: true if angle of attack in file is given in radians\n\n\n\n\n\n","category":"type"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"and all three (angle of attack, Reynolds number, Mach number):","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"AlphaReMachAF","category":"page"},{"location":"reference/#CCBlade.AlphaReMachAF","page":"API Reference","title":"CCBlade.AlphaReMachAF","text":"AlphaReMachAF(alpha, Re, Mach, cl, cd, info)\nAlphaReMachAF(alpha, Re, Mach, cl, cd)\nAlphaReMachAF(filenames::Matrix{String}; radians=true)\n\nAirfoil data that varies with angle of attack, Reynolds number, and Mach number.   Data is fit with a recursive Akima spline.\n\nArguments\n\nalpha::Vector{Float64}: angles of attack\nRe::Vector{Float64}: Reynolds numbers\nMach::Vector{Float64}: Mach numbers\ncl::Array{Float64}: lift coefficients where cl[i, j, k] corresponds to alpha[i], Re[j], Mach[k]\ncd::Array{Float64}: drag coefficients where cd[i, j, k] corresponds to alpha[i], Re[j], Mach[k]\ninfo::String: a description of this airfoil data (just informational)\n\nor files with one per Re/Mach combination\n\nArguments\n\nfilenames::Matrix{String}: name/path of files to read in.  filenames[i, j] corresponds to Re[i] Mach[j] with Reynolds number and Mach number in ascending order.\nradians::Bool: true if angle of attack in file is given in radians\n\n\n\n\n\n","category":"type"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"More generally the user can provide any function of the form cl, cd = af(alpha, Re Mach) or can create their own subtypes of AFType to be used by CCBlade.","category":"page"},{"location":"reference/#Airfoil-Files","page":"API Reference","title":"Airfoil Files","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Because many of these formats require storing long vectors/matrices of data, it is convenient to store them in files.  There are multiple convenience methods for reading and writing files based on the implemented AFType subtypes.  The file format for all airfoil files is as follows:","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"______\ninformational line (arbitrary string just for information)\nRe (float, Reynolds number data was taken at)\nMach (float, Mach number data was taken at)\nalpha1  cl1  cd1  (columns of data separated by space for angle of attack, lift coefficient, and drag coefficient)\nalpha2  cl2  cd2\nalpha3  cl3  cd3\n...\n","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"In addition to reading these in directly, you can write data to a file, which is dispatched based on the AFType.","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"write_af","category":"page"},{"location":"reference/#CCBlade.write_af","page":"API Reference","title":"CCBlade.write_af","text":"write_af(filename(s), af::AFType; radians=true)\n\nWrite airfoil data to file\n\nArguments\n\nfilename(s)::String or Vector{String} or Matrix{String}: name/path of file to write to\naf::AFType: writing is dispatched based on type (AlphaAF, AlphaReAF, etc.)\nradians::Bool: true if you want angle of attack to be written in radians\n\n\n\n\n\n","category":"function"},{"location":"reference/#Airfoil-(and-Tip)-Corrections","page":"API Reference","title":"Airfoil (and Tip) Corrections","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Various airfoil correction methods exist for Mach number, Reynolds number, and rotation effects.  Additionally, custom tip loss corrections can be specified.  For Mach number and Reynolds number the form is similar.  For Mach number, there is the mach_correction function that dispatches based on subtypes of MachCorrection.","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"mach_correction(::MachCorrection, ::Any, ::Any, ::Any)","category":"page"},{"location":"reference/#CCBlade.mach_correction-Tuple{MachCorrection, Any, Any, Any}","page":"API Reference","title":"CCBlade.mach_correction","text":"mach_correction(::MachCorrection, cl, cd, Mach)\n\nMach number correction for lift/drag coefficient\n\nArguments\n\nmc::MachCorrection: used for dispatch\ncl::Float64: lift coefficient before correction\ncd::Float64: drag coefficient before correction\nMach::Float64: Mach number\n\nReturns\n\ncl::Float64: lift coefficient after correction\ncd::Float64: drag coefficient after correction\n\n\n\n\n\n","category":"method"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"For example, a Prandtl-Glauert correction is available:","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"mach_correction(::PrandtlGlauert, ::Any, ::Any, ::Any)","category":"page"},{"location":"reference/#CCBlade.mach_correction-Tuple{PrandtlGlauert, Any, Any, Any}","page":"API Reference","title":"CCBlade.mach_correction","text":"mach_correction(::PrandtlGlauert, cl, cd, Mach)\n\nPrandtl/Glauert Mach number correction for lift coefficient\n\n\n\n\n\n","category":"method"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Similarly, Reynolds number corrections use the re_correction function with dispatching based on subtypes of ReCorrection","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"re_correction(::ReCorrection, ::Any, ::Any, ::Any)","category":"page"},{"location":"reference/#CCBlade.re_correction-Tuple{ReCorrection, Any, Any, Any}","page":"API Reference","title":"CCBlade.re_correction","text":"re_correction(re::ReCorrection, cl, cd, Re)\n\nReynolds number correction for lift/drag coefficient\n\nArguments\n\nre::ReCorrection: used for dispatch\ncl::Float64: lift coefficient before correction\ncd::Float64: drag coefficient before correction\nRe::Float64: Reynolds number\n\nReturns\n\ncl::Float64: lift coefficient after correction\ncd::Float64: drag coefficient after correction\n\n\n\n\n\n","category":"method"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"A skin friction model based on flat plate increases in drag coefficient with Reynolds number is implemented:","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"SkinFriction","category":"page"},{"location":"reference/#CCBlade.SkinFriction","page":"API Reference","title":"CCBlade.SkinFriction","text":"SkinFriction(Re0, p)\n\nSkin friction model for a flat plate. cd *= (Re0 / Re)^p\n\nArguments\n\nRe0::Float64: reference Reynolds number (i.e., no corrections at this number)\np::Float64: exponent in flat plate model.  0.5 for laminar (Blasius solution), ~0.2 for fully turbulent (Schlichting empirical fit)\n\n\n\n\n\n","category":"type"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"For convenience, there is also LaminarSkinFriction(Re0) and TurbulentSkinFriction(Re0) to set the exponent p for typical values for fully laminar and fully turbulent flow respectively.","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Rotational corrections for 3D stall delay use the rotation_correction function that dispatches on subtypes of RotationCorrection.","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"rotation_correction","category":"page"},{"location":"reference/#CCBlade.rotation_correction","page":"API Reference","title":"CCBlade.rotation_correction","text":"rotation_correction(rc::RotationCorrection, cl, cd, cr, rR, tsr, alpha, phi=alpha, alpha_max_corr=30*pi/180)\n\nRotation correction (3D stall delay).\n\nArguments\n\nrc::RotationCorrection: used for dispatch\ncl::Float64: lift coefficient before correction\ncd::Float64: drag coefficient before correction\ncr::Float64: local chord / local radius\nrR::Float64: local radius / tip radius\ntsr::Float64: local tip speed ratio (Omega r / Vinf)\nalpha::Float64: local angle of attack\nphi::Float64: local inflow angles (defaults to angle of attack is precomputing since it is only known for on-the-fly computations)\nalpha_max_corr::Float64: angle of attack for maximum correction (tapers off to zero by 90 degrees)\n\nReturns\n\ncl::Float64: lift coefficient after correction\ncd::Float64: drag coefficient after correction\n\n\n\n\n\n","category":"function"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"A supplied correction method uses the Du-Selig method for lift and the Eggers method for drag.","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"DuSeligEggers","category":"page"},{"location":"reference/#CCBlade.DuSeligEggers","page":"API Reference","title":"CCBlade.DuSeligEggers","text":"DuSeligEggers(a, b, d, m, alpha0)\nDuSeligEggers(a=1.0, b=1.0, d=1.0, m=2*pi, alpha0=0.0)  # uses defaults\n\nDuSelig correction for lift an Eggers correction for drag.\n\nArguments\n\na, b, d::Float64: parameters in Du-Selig paper.  Normally just 1.0 for each.\nm::Float64: lift curve slope.  Defaults to 2 pi for zero argument version.\nalpha0::Float64: zero-lift angle of attack.  Defaults to 0 for zero argument version.\n\n\n\n\n\n","category":"type"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Finally, tip loss corrections are provided by the tip_correction function dispatching based on TipCorrection.","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"tip_correction","category":"page"},{"location":"reference/#CCBlade.tip_correction","page":"API Reference","title":"CCBlade.tip_correction","text":"tip_correction(::TipCorrection, r, Rhub, Rtip, phi, B)\n\nTip corrections for 3D flow.\n\nArguments\n\ntc::TipCorrection: used for dispatch\nr::Float64: local radius\nRhub::Float64: hub radius\nRtip::Float64: tip radius\nphi::Float64: inflow angle\nB::Integer: number of blades\n\nReturns\n\nF::Float64: tip loss factor to multiple against loads.\n\n\n\n\n\n","category":"function"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Two provided corrections are Prandtl tip loss, and Prandtl tip and hub loss.","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"PrandtlTip\nPrandtlTipHub","category":"page"},{"location":"reference/#CCBlade.PrandtlTip","page":"API Reference","title":"CCBlade.PrandtlTip","text":"PrandtlTip()\n\nStandard Prandtl tip loss correction.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CCBlade.PrandtlTipHub","page":"API Reference","title":"CCBlade.PrandtlTipHub","text":"PrandtlTipHub()\n\nStandard Prandtl tip loss correction plus hub loss correction of same form.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Airfoil-Extrapolation","page":"API Reference","title":"Airfoil Extrapolation","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"While not used in CCBlade directly, for convenience a preprocessing method is provided to extrapolate airfoil coefficient data from -pi to pi.","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"viterna","category":"page"},{"location":"reference/#CCBlade.viterna","page":"API Reference","title":"CCBlade.viterna","text":"viterna(alpha, cl, cd, cr75, nalpha=50)\n\nViterna extrapolation.  Follows Viterna paper and somewhat follows NREL version of AirfoilPrep, but with some modifications for better robustness and smoothness.\n\nArguments\n\nalpha::Vector{Float64}: angles of attack\ncl::Vector{Float64}: correspnding lift coefficients\ncd::Vector{Float64}: correspnding drag coefficients\ncr75::Float64: chord/Rtip at 75% Rtip\nnalpha::Int64: number of discrete points (angles of attack) to include in extrapolation\n\nReturns\n\nalpha::Vector{Float64}: angle of attack from -pi to pi\ncl::Vector{Float64}: correspnding extrapolated lift coefficients\ncd::Vector{Float64}: correspnding extrapolated drag coefficients\n\n\n\n\n\n","category":"function"},{"location":"#CCBlade-Documentation","page":"Intro","title":"CCBlade Documentation","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"Summary: A blade element momentum method for propellers and turbines. ","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Author: Andrew Ning","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Features:","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Methodology is provably convergent (see http://dx.doi.org/10.1002/we.1636 although multiple improvements have been made since then)\nPrandtl hub/tip losses (or user-defined losses)\nGlauert/Buhl empirical region for high thrust turbines\nConvenience functions for inflow with shear, precone, yaw, tilt, and azimuth\nCan do airfoil corrections beforehand or on the fly (Mach, Reynolds, rotation)\nAllows for flow reversals (negative inflow/rotation velocities)\nAllows for a hover condition (only rotation, no inflow) and rotor locked (no rotation, only inflow)\nCompatible with AD tools like ForwardDiff","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Installation:","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"pkg> add CCBlade","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Documentation:","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Start with the quick start tutorial to learn basic usage.\nMore advanced or specific queries are addressed in the guided examples.\nFull details of the API are listed in reference.\nFull details of the theory are linked from the theory page.","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Run Unit Tests:","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"pkg> activate .\npkg> test","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Citing:","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Ning, A., Using Blade Element Momentum Methods with Gradient-Based Design Optimization, Apr. 2020, (in review).","category":"page"},{"location":"tutorial/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"This starter tutorial walks through the mechanics of running a analysis.  This is designing as a starting point and does not explain every option or consideration.  More specific and advanced usage are described in the how to guide.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"We will simulate the APC thin electric 10 x 5 propeller.  The geometry, and wind tunnel data for this propeller is available from UIUC. Let's load CCBlade and a plotting package (I chose to use PyPlot in this example).  ","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"using CCBlade\nusing PyPlot","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"There are two parts of the geometry we need to define: the first are quantities for the whole rotor, and the second part defines properties that vary along the blade radius.  For the rotor, we only need to define the hub radius, tip radius, and the number of blades.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"This is a two-bladed propeller, and the 10 in the name (10 x 5) means it has a diameter of 10 inches (and so the tip radius is half of that).  I prefer to do all calculations in metric units so I'll convert it.  From the geometry table for this propeller we see that the hub radius is less than 015 R_tip.  It isn't defined exactly, and is less critical, we'll assume 010 R_tip for this example.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"Rtip = 10/2.0 * 0.0254  # inches to meters\nRhub = 0.10*Rtip\nB = 2  # number of blades\n\nrotor = Rotor(Rhub, Rtip, B)\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"Next, we define the geometry along the different radial stations.   The more radial stations we add, the more points we will compute loads at.  There is a tradeoff here in computational time and accuracy in representing (and integrating) loads. The geometry table defines the normalized radial stations, normalized chord, and the twist angle in degrees.  CCBlade assumes all angles are given in radians so we will need to convert that, we will also unnormalize the radius and chord (alternatively we could do everything in consistent nondimensional units).","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"propgeom = [\n0.15   0.130   32.76\n0.20   0.149   37.19\n0.25   0.173   33.54\n0.30   0.189   29.25\n0.35   0.197   25.64\n0.40   0.201   22.54\n0.45   0.200   20.27\n0.50   0.194   18.46\n0.55   0.186   17.05\n0.60   0.174   15.97\n0.65   0.160   14.87\n0.70   0.145   14.09\n0.75   0.128   13.39\n0.80   0.112   12.84\n0.85   0.096   12.25\n0.90   0.081   11.37\n0.95   0.061   10.19\n1.00   0.041   8.99\n]\n\nr = propgeom[:, 1] * Rtip\nchord = propgeom[:, 2] * Rtip\ntheta = propgeom[:, 3] * pi/180\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"The remaining piece in defining the geometry is the airfoils.  We don't actually define the airfoil geometry, but rather the aerodynamic performance data of the airfoils at each station (lift and drag coefficients).  This propeller uses the NACA 4412 airfoil, for which experimental data is readily available, or for which computational data can be easily provided. The data for this airfoil is contained in a file \"naca4412.dat\" (in the data directory of the repository).  The file format is discussed in Airfoil Files.  There are some important details to be aware of when providing airfoil data-the way this file was constructed is covered in Airfoil Data.  For now, we just assume provided airfoil data.  The file extension is not important, all that matters is that the format has columns of data for: angle of attack | lift coefficient | drag coefficient (after an informational header row, a row for Reynolds number, and a row for Mach number).  We can either put in the full or relative path to the file, for example if you were in the home directory of this repository:","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"af = AlphaAF(\"data/naca4412.dat\")\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"or we can change directory (note the semicolon to enter shell mode from the REPL):","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"; cd data\naf = AlphaAF(\"naca4412.dat\")","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"We can now define the sections using this airfoil data.  Since Section is defined for one section, and we'd like to define them all simultaneously, we use broadcasting (see the dot after Section).  The airfoil is the same for all stations along the rotor so we wrap it in a Ref() call so that it can be broadcast across.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"sections = Section.(r, chord, theta, Ref(af))\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"Next, we define the operating point(s).  You can define your own arbitrary inflow struct, but for this example we will assume constant inflow across the rotor.  We again use broadcasting because the velocities will vary at each radial station r.  For this simple method we just need to know the freestream speed, rotation speed, and the air density.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"\nVinf = 5.0\nOmega = 5400*pi/30  # convert to rad/s\nrho = 1.225\n\nop = simple_op.(Vinf, Omega, r, rho)\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"We have now defined the requisite inputs and can start using the BEM methodology.  The solve function is the core of the BEM. Note that we use broadcasting to solve all sections in one call.  However, since rotor is not an Array, and is the same for all sections, we wrap it in Ref so that it can broadcast as a \"scalar\".","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"\nout = solve.(Ref(rotor), sections, op)\n\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"There are many outputs, and although the return variable is actually an array of structs, convenience methods are provided to access the fields as if it was a struct of arrays.  For example, we can access the angles of attack at each radial station as:","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"out.alpha*180/pi  # angle of attack in degrees","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"The full list of outputs and their positive directions are shown in Output Struct.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"Let's now plot the distributed loads.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"figure()\nplot(r/Rtip, out.Np)\nplot(r/Rtip, out.Tp)\nxlabel(\"r/Rtip\")\nylabel(\"distributed loads (N/m)\")\nlegend([\"flapwise\", \"lead-lag\"])\nsavefig(\"loads-prop.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"(Image: )","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"We will also look at the induced velocities.  For propellers these velocities are useful to assess, for example, prop-on-wing interactions.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"figure()\nplot(r/Rtip, out.u/Vinf)\nplot(r/Rtip, out.v/Vinf)\nxlabel(\"r/Rtip\")\nylabel(\"(normalized) induced velocity at rotor disk\")\nlegend([\"axial velocity\", \"swirl velocity\"])\nsavefig(\"velocity-prop.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"(Image: )","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"As before, we'd like to evaluate integrated quantities at multiple conditions in a for loop (advance ratios as is convention for propellers).  The normalization conventions for a propeller are:","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"beginaligned\nC_T = fracTrho n^2 D^4\nC_Q = fracQrho n^2 D^5\nC_P = fracPrho n^3 D^5 = fracC_Q2 pi\neta = fracC_T JC_P\nendaligned","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"where","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"beginaligned\nn = fracOmega2pi text rev per sec\nD = 2 R_tip cos(textprecone)\nJ = fracVn D\nendaligned","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"note: Note\nEfficiency is set to zero if the thrust is negative (producing drag).  ","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"The code below performs this analysis then plots thrust coefficient, power coefficient, and efficiency as a function of advance ratio as compared to the experimental data.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"nJ = 20  # number of advance ratios\n\nJ = range(0.1, 0.6, length=nJ)  # advance ratio\n\nOmega = 5400.0*pi/30\nn = Omega/(2*pi)\nD = 2*Rtip\n\neff = zeros(nJ)\nCT = zeros(nJ)\nCQ = zeros(nJ)\n\nfor i = 1:nJ\n    local Vinf = J[i] * D * n\n\n    local op = simple_op.(Vinf, Omega, r, rho)\n    outputs = solve.(Ref(rotor), sections, op)\n    T, Q = thrusttorque(rotor, sections, outputs)\n    eff[i], CT[i], CQ[i] = nondim(T, Q, Vinf, Omega, rho, rotor, \"propeller\")\n\nend\n\nexp = [\n0.113   0.0912   0.0381   0.271\n0.145   0.0890   0.0386   0.335\n0.174   0.0864   0.0389   0.387\n0.200   0.0834   0.0389   0.429\n0.233   0.0786   0.0387   0.474\n0.260   0.0734   0.0378   0.505\n0.291   0.0662   0.0360   0.536\n0.316   0.0612   0.0347   0.557\n0.346   0.0543   0.0323   0.580\n0.375   0.0489   0.0305   0.603\n0.401   0.0451   0.0291   0.620\n0.432   0.0401   0.0272   0.635\n0.466   0.0345   0.0250   0.644\n0.493   0.0297   0.0229   0.640\n0.519   0.0254   0.0210   0.630\n0.548   0.0204   0.0188   0.595\n0.581   0.0145   0.0162   0.520\n]\nJexp = exp[:, 1]\nCTexp = exp[:, 2]\nCPexp = exp[:, 3]\netaexp = exp[:, 4]\n\n\nfigure()\nplot(J, CT)\nplot(J, CQ*2*pi)\nplot(Jexp, CTexp, \"ko\")\nplot(Jexp, CPexp, \"ko\")\nxlabel(L\"J\")\nlegend([L\"C_T\", L\"C_P\", \"experimental\"])\nsavefig(\"ctcp-prop.svg\") # hide\n\nfigure()\nplot(J, eff)\nplot(Jexp, etaexp, \"ko\")\nxlabel(L\"J\")\nylabel(L\"\\eta\")\nlegend([\"CCBlade\", \"experimental\"])\nsavefig(\"eta-prop.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"(Image: ) (Image: )","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"There is reasonable agreement in thrust and torque coefficient, certainly within experimental/computational error.  Efficiency is overpredicted, but always harder to match as it is the ratio of two estimated values.  Spending time providing more accurate airfoil data could improve the accuracy, and is discussed more in Airfoil Data.","category":"page"}]
}
